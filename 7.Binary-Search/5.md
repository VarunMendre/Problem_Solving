# Problem 1: Find Minimum in Rotated Sorted Array

We are given an array `nums` sorted in ascending order and then rotated at some unknown pivot. The task is to find the **minimum element** in this rotated sorted array.

---

## 1. Brute Force Approach

### Intuition / Approach
- The simplest way is to perform a **linear search**.
- We iterate through the entire array and keep track of the smallest element encountered.
- Since the array is rotated, the minimum element could be anywhere, so scanning all elements guarantees correctness.

### Dry Run
Consider `nums = [4,5,6,7,0,1,2]`
1. Initialize `minVal = INT_MAX`
2. Traverse array:
   - Compare each element with `minVal`
   - Update if smaller
3. After traversal, `minVal = 0`

### Code
```cpp
int findMin(vector<int>& nums) {
    int n = nums.size();
    int minVal = INT_MAX;
    for(int i = 0; i < n; i++) {
        minVal = min(minVal, nums[i]);
    }
    return minVal;
}
```

### Time & Space Complexity
- **Time Complexity:** O(n), as we scan all elements.
- **Space Complexity:** O(1), no extra space used.

---

## 2. Optimal Approach (Binary Search)

### Intuition / Approach
- The rotated sorted array has two sorted halves.
- We can use **binary search** to locate the minimum element in O(log n).
- Idea:
  1. If the left half `nums[low..mid]` is sorted, the minimum must lie at `nums[low]`. Then discard left half and move right.
  2. If the right half `nums[mid..high]` is sorted, the minimum must lie at `nums[mid]`. Then discard right half and move left.
- Keep track of the minimum value found during the process.

### Dry Run
Consider `nums = [4,5,6,7,0,1,2]`
1. `low = 0, high = 6, ans = INT_MAX`
2. mid = 3 → `nums[mid] = 7`
   - Left half [4,7] is sorted → `ans = min(ans, 4)` → move `low = mid+1 = 4`
3. `low = 4, high = 6`
   - mid = 5 → `nums[mid] = 1`
   - Right half [1,2] is sorted, but left side is not → `ans = min(ans, 1)` → move `high = mid-1 = 4`
4. `low = 4, high = 4`
   - mid = 4 → `nums[mid] = 0`
   - Left side [0] sorted → `ans = min(ans, 0)` → move `low = mid+1 = 5`
5. Loop ends, `ans = 0`

### Code
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int low = 0, high = n - 1;
        int ans = INT_MAX;

        while(low <= high) {
            int mid = (low + high) / 2;

            if(nums[low] <= nums[mid]) {
                ans = min(ans, nums[low]);
                low = mid + 1;
            }
            else {
                ans = min(ans, nums[mid]);
                high = mid - 1;
            }
        }
        return ans;
    }
};
```

### Time & Space Complexity
- **Time Complexity:** O(log n), due to binary search.
- **Space Complexity:** O(1), constant extra space.

---

## Final Notes
- Brute force is straightforward but inefficient for large arrays.
- Optimal binary search approach leverages the rotated sorted property, reducing complexity to O(log n).



# Problem 2: Find Rotation Count in Rotated Sorted Array

## Problem Statement

You are given an array `arr` having `n` distinct integers sorted in
ascending order.\
The array is right rotated `r` times.\
Find the minimum value of `r`.

Example: arr = \[3,4,5,1,2\] → r = 3.

------------------------------------------------------------------------

### 1. Approach/Intuition

We again use **binary search** to find the index of the minimum
element:\
- If the current search space is sorted, then the minimum is at `low`.\
- Otherwise, check which half is sorted and eliminate it accordingly.\
The index of the minimum element = number of rotations.

------------------------------------------------------------------------

### 2. Dry Run

Example: arr = \[3,4,5,1,2\]

-   Step 1: low=0, high=4, mid=2 → arr\[0\]=3 \<= arr\[2\]=5 → ans=3 at
    index=0, move right (low=3).\
-   Step 2: low=3, high=4, mid=3 → arr\[3\]=1 → ans=1 at index=3, search
    ends.

Answer = 3 rotations.

------------------------------------------------------------------------

### 3. Code

``` cpp
#include<bits/stdc++.h>
int findKRotation(vector<int> &arr) {
    int low = 0, high = arr.size() - 1;
    int ans = INT_MAX;
    int index = -1;

    while (low <= high) {
        int mid = (low + high) / 2;

        if (arr[low] <= arr[high]) {
            if (arr[low] < ans) {
                index = low;
                ans = arr[low];
            }
            break;
        }

        if (arr[low] <= arr[mid]) {
            if (arr[low] < ans) {
                index = low;
                ans = arr[low];
            }
            low = mid + 1;
        } else {
            if (arr[mid] < ans) {
                index = mid;
                ans = arr[mid];
            }
            high = mid - 1;
        }
    }
    return index;
}
```

------------------------------------------------------------------------

### 4. Time & Space Complexity

-   **Time Complexity:** O(log n) (binary search).\
-   **Space Complexity:** O(1) (constant extra space).
