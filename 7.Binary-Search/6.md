# Problem: Single Element in a Sorted Array

You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.  
Return the single element that appears only once.  
Your solution must run in **O(log n)** time and **O(1)** space.

---

## Brute Force Approach

### 1. Approach / Intuition
- Since the array is sorted and every element appears twice except one, we can simply traverse the array linearly and check for the unique element.  
- At each index, compare the current element with its neighbors. If it doesn't match with either, it's the unique one.  
- Edge cases: unique element may lie at the **first index** or **last index**.

### 2. Dry Run
Example: `nums = [1,1,2,3,3,4,4,8,8]`  

- i = 0 → nums[0] = 1 == nums[1] → skip  
- i = 2 → nums[2] = 2 ≠ nums[1] and nums[2] ≠ nums[3] → unique element found → return 2  

Output = 2

### 3. Code
```cpp
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int n = nums.size();

        if(n == 1) return nums[0];
        for(int i = 0; i < n; i++ ) {
            if(i == 0){
                if(nums[i] != nums[i + 1]) return nums[i];
            }else if(i == n -1) {
                if(nums[i] != nums[i - 1]) return nums[i];
            }else {
                if(nums[i] != nums[i - 1] && nums[i] != nums[i +1]) return nums[i];
            }
        }
        return -1;
    }
};
```

### 4. Time & Space Complexity
- **Time Complexity:** O(n), since we traverse the array linearly.  
- **Space Complexity:** O(1), as no extra space is used.

---

## Optimal Approach (Binary Search)

### 1. Approach / Intuition
- Since the array is sorted, we can apply **binary search** to find the single element in **O(log n)**.  
- Key observation:  
  - Pairs appear in even-odd index positions before the single element.  
  - After the single element, pairs appear in odd-even positions.  
- Use binary search and check:
  - If `nums[mid]` is the unique element.  
  - Else adjust search space based on index parity and neighbor equality.

### 2. Dry Run
Example: `nums = [1,1,2,3,3,4,4,8,8]`  

- low = 1, high = 7  
- mid = 4 → nums[4] = 3, nums[4] == nums[3] → pair found on even-odd → unique lies right → low = 5  
- low = 5, high = 7  
- mid = 6 → nums[6] = 4, nums[6] == nums[5] → pair found → move right → low = 7  
- mid = 7 → nums[7] = 8, nums[7] == nums[8] → no unique → but condition narrows → return 2 (already found earlier).  

Output = 2

### 3. Code
```cpp
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int n = nums.size();

        if(n == 1) return nums[0];

        if(nums[0] != nums[1]) return nums[0];
        if(nums[n-1] != nums[n - 2]) return nums[n - 1];

        int low = 1, high = n - 2;
        while(low <= high) {
            int mid = (low + high) / 2;

            if(nums[mid] != nums[mid - 1] && nums[mid] != nums[mid + 1]) {
                return nums[mid];
            }
            else if((mid % 2 == 1 && nums[mid] == nums[mid - 1]) 
            || (mid % 2 == 0 && nums[mid] == nums[mid + 1])) {
                low = mid + 1;
            }
            else {
                high = mid - 1;
            }
        }
        return -1;
    }
};
```

### 4. Time & Space Complexity
- **Time Complexity:** O(log n), since binary search is used.  
- **Space Complexity:** O(1), no extra space is used.

---
