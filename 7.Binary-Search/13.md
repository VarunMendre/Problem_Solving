# Aggressive Cows Problem

## Problem Statement
You are given an array `arr` consisting of `n` integers which denote the position of a stall.  
You are also given an integer `k` which denotes the number of aggressive cows.  
You are tasked with assigning stalls to `k` cows such that the **minimum distance** between any two of them is the **maximum possible**.  
Print the maximum possible minimum distance.

**Example:**  
Input: `n = 3`, `k = 2`, `arr = {1, 2, 3}`  
Output: `2`  
Explanation: The maximum possible minimum distance will be 2 when 2 cows are placed at positions `{1, 3}`. Here distance between cows is 2.

---

# Brute Force Approach

### 1. Approach / Intuition
- Place cows in stalls sequentially and check if it's possible to place all `k` cows with at least a given minimum distance.  
- We use a helper function `canWePlace` which returns `true` if cows can be placed with the given distance, else `false`.  
- Try all possible distances.

### 2. Dry Run
Input: `arr = {1, 2, 3}`, `k = 2`  
- Sort stalls → `{1, 2, 3}`  
- Suppose distance = 2.  
  - Place first cow at position `1`.  
  - Next stall `3` is at distance `2` from `1`, so place second cow at `3`.  
  - We successfully placed `2` cows → return `true`.  

### 3. Code
```cpp
bool canWePlace(vector<int> &stalls, int dist, int k) {
    int cntcows = 1, last = stalls[0];

    for(int i = 1; i < stalls.size(); i++) {
        if(stalls[i] - last >= dist) {
            cntcows++;
            last = stalls[i];
        }
        if(cntcows >= k) return true;
    }
    return false;
}
```

### 4. Time & Space Complexity
- **Time Complexity:** O(N) for checking each placement.  
- **Space Complexity:** O(1) (no extra space used).  

---

# Optimal Approach (Binary Search)

### 1. Approach / Intuition
- Instead of linearly testing all distances, apply **binary search** on the answer (minimum distance).  
- The search space is between `0` and `max(stalls) - min(stalls)`.  
- For each `mid` distance, check if it's possible to place cows using `canWePlace`.  
- Adjust search boundaries accordingly.

### 2. Dry Run
Input: `arr = {1, 2, 3}`, `k = 2`  
- Sort stalls → `{1, 2, 3}`  
- low = 0, high = 2  
- mid = 1 → can place cows → move `low = 2`.  
- mid = 2 → can place cows → move `low = 3`.  
- Now `low > high`, exit loop.  
- Answer = `high = 2`.  

### 3. Code
```cpp
bool canWePlace(vector<int> &stalls, int dist, int k) {
    int cntcows = 1, last = stalls[0];

    for(int i = 1; i < stalls.size(); i++) {
        if(stalls[i] - last >= dist) {
            cntcows++;
            last = stalls[i];
        }
        if(cntcows >= k) return true;
    }
    return false;
}

int aggressiveCows(vector<int> &stalls, int k)
{
    sort(stalls.begin(), stalls.end());

    int n = stalls.size();
    int low = 0, high = stalls[n - 1] - stalls[0];

    while(low <= high) {
        int mid = (low + high) / 2;

        if(canWePlace(stalls, mid, k) == true) {
            low = mid + 1;
        }
        else {
            high = mid - 1;
        }
    }

    return high;
}
```

### 4. Time & Space Complexity
- **Time Complexity:** O(N log(max_distance))  
  - N for checking placement, log(max_distance) for binary search.  
- **Space Complexity:** O(1) (no extra space used).  
