# Problem 1: Find First and Last Position of Element in Sorted Array

## Problem Statement
Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given target value.  
If target is not found in the array, return `[-1, -1]`.  
The algorithm must run in **O(log n)** time complexity.

---

## Optimal Solution 1

### 1. Intuition / Approach
We use **binary search-based lower and upper bounds**:
- `lowerBound` finds the first index where element >= target.
- `upperBound` finds the first index where element > target.  
The range is then `[lowerBound, upperBound - 1]`.

### 2. Dry Run
Input: `nums = [5,7,7,8,8,10], target = 8`  
- `lowerBound(8)` → returns 3 (first index of 8).  
- `upperBound(8)` → returns 5 (index of first element > 8).  
Final result → `[3, 4]`.

### 3. Code
```cpp
class Solution {
private:
    int lowerBound(vector<int> arr, int n, int x) {
        int low = 0, high = n - 1;
        int ans = n;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (arr[mid] >= x) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return ans;
    }

    int upperBound(vector<int> &arr, int n, int x) {
        int low = 0, high = n - 1;
        int ans = n;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (arr[mid] > x) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return ans;
    }
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int n = nums.size();
        int lb = lowerBound(nums, n, target);
        if(lb == n || nums[lb] != target) return {-1, -1};
        return {lb, upperBound(nums, n, target) - 1};
    }
};
```

### 4. Time & Space Complexity
- **Time Complexity**: O(log n) (binary search twice).  
- **Space Complexity**: O(1) (no extra memory).  

---

## Optimal Solution 2

### 1. Intuition / Approach
Instead of predefined lower/upper bounds, we directly implement two binary searches:
- One for **first occurrence** of target.
- One for **last occurrence** of target.

### 2. Dry Run
Input: `nums = [5,7,7,8,8,10], target = 8`  
- First occurrence → 3.  
- Last occurrence → 4.  
Final result → `[3, 4]`.

### 3. Code
```cpp
class Solution {
private:
    int firstOcurrece(vector<int>&nums, int n, int k) {
        int low = 0, high = n - 1;
        int firstInd = -1;
        while(low <= high) {
            int mid = (low + high) / 2;
            if(nums[mid] == k) {
                firstInd = mid;
                high = mid - 1;
            }
            else if(nums[mid] < k) low = mid + 1;
            else high = mid - 1;
        }
        return firstInd;
    } 
    int lastOcurrece(vector<int>&nums, int n, int k) {
        int low = 0, high = n - 1;
        int lastInd = -1;
        while(low <= high) {
            int mid = (low + high) / 2;
            if(nums[mid] == k) {
                lastInd = mid;
                low = mid + 1;
            }
            else if(nums[mid] < k) low = mid + 1;
            else high = mid - 1;
        }
        return lastInd;
    } 
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int n = nums.size();
        int first = firstOcurrece(nums, n, target);
        if(first == -1) return {-1, -1};
        int last = lastOcurrece(nums, n, target);
        return {first, last};
    }
};
```

### 4. Time & Space Complexity
- **Time Complexity**: O(log n).  
- **Space Complexity**: O(1).  

---

# Problem 2: Count Total Occurrences of Element

## Problem Statement
Given a sorted array/list of integers `arr` of size `n` and an integer `x`, find the **total number of occurrences** of `x`.  

### Example:
Input: `arr = [1,1,1,2,2,3,3], x = 3`  
Output: `2`  

---

### 1. Intuition / Approach
We use two binary searches to find the **first and last occurrence** of `x`.  
The total count = `(lastIndex - firstIndex + 1)`.  
If element not found, return 0.

### 2. Dry Run
Input: `arr = [1,1,1,2,2,3,3], x = 3`  
- First occurrence of 3 → index 5.  
- Last occurrence of 3 → index 6.  
Count = `6 - 5 + 1 = 2`.  

### 3. Code
```cpp
int firstOccurrence(vector<int> &arr, int n, int k) {
    int low = 0, high = n - 1;
    int first = -1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] == k) {
            first = mid;
            high = mid - 1;
        }
        else if (arr[mid] < k) {
            low = mid + 1;
        }
        else {
            high = mid - 1;
        }
    }
    return first;
}

int lastOccurrence(vector<int> &arr, int n, int k) {
    int low = 0, high = n - 1;
    int last = -1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] == k) {
            last = mid;
            low = mid + 1;
        }
        else if (arr[mid] < k) {
            low = mid + 1;
        }
        else {
            high = mid - 1;
        }
    }
    return last;
}

pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k) {
    int first = firstOccurrence(arr, n, k);
    if (first == -1) return { -1, -1};
    int last = lastOccurrence(arr, n, k);
    return {first, last};
}

int count(vector<int>& arr, int n, int x) {
    pair<int, int> ans = firstAndLastPosition(arr, n, x);
    if (ans.first == -1) return 0;
    return (ans.second - ans.first + 1);
}
```

### 4. Time & Space Complexity
- **Time Complexity**: O(log n).  
- **Space Complexity**: O(1).  
