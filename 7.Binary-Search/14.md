# Book Allocation Problem

## Problem Statement

We are given an array `arr[]` where each element represents the number
of pages in a book. We need to allocate books to `m` students such
that: - Each student gets **contiguous books**. - The **maximum number
of pages allocated to a student is minimized**.

If allocation is not possible (i.e., `m > n`), return `-1`.

------------------------------------------------------------------------

# 1. Naive Approach

### Approach / Intuition

-   The maximum pages any student can get lies between `max(arr)` and
    `sum(arr)`.
-   We try every possible value of `pages` in this range.
-   For each value, we check how many students are required using
    `countStudents()`.
-   If exactly `m` students are required, that value is our answer.
-   Brute-force since we check every possible `pages` value.

### Dry Run

arr = \[12, 34, 67, 90\], n = 4, m = 2\
- max(arr) = 90, sum(arr) = 203\
- Range = \[90 ... 203\]

Check pages = 90 → students = 4 (too many)\
Check pages = 100 → students = 3 (still too many)\
Check pages = 113 → students = 2 ✅\
Thus, answer = 113.

### Code

``` cpp
int countStudents(vector<int> &arr, int pages) {
    int n = arr.size();
    int students = 1;
    long long pagesStudent = 0;
    for (int i = 0; i < n; i++) {
        if (pagesStudent + arr[i] <= pages) {
            pagesStudent += arr[i];
        } else {
            students++;
            pagesStudent = arr[i];
        }
    }
    return students;
}

int findPages(vector<int>& arr, int n, int m) {
    if (m > n) return -1;
    int low = *max_element(arr.begin(), arr.end());
    int high = accumulate(arr.begin(), arr.end(), 0);
    for (int pages = low; pages <= high; pages++) {
        if (countStudents(arr, pages) == m) {
            return pages;
        }
    }
    return low;
}
```

### Time & Space Complexity

-   **Time Complexity:** `O(N * (sum(arr) - max(arr) + 1))`\
-   **Space Complexity:** `O(1)`

------------------------------------------------------------------------

# 2. Optimal Approach (Binary Search on Answer)

### Approach / Intuition

-   Instead of checking every possible value of `pages`, we use **Binary
    Search**.
-   Search space = \[max(arr), sum(arr)\].
-   For each `mid`, calculate number of students required.\
-   If students \> m → increase `low` (need more pages per student).\
-   Else decrease `high`.\
-   Finally, `low` is the minimum pages.

### Dry Run

arr = \[12, 34, 67, 90\], m = 2\
- low = 90, high = 203

mid = 146 → students = 2 ✅ → high = 145\
mid = 117 → students = 2 ✅ → high = 116\
mid = 103 → students = 3 ❌ → low = 104\
mid = 110 → students = 2 ✅ → high = 109\
mid = 106 → students = 3 ❌ → low = 107\
mid = 107 → students = 2 ✅ → high = 106

Answer = 113 (final low).

### Code

``` cpp
#include<bits/stdc++.h>
int cntStudents(vector<int>& arr, int pages) {
    int students = 1; 
    long long studentPages = 0;
    for(int i = 0; i < arr.size(); i++) {
        if(studentPages + arr[i] <= pages) {
            studentPages += arr[i];
        } else {
            students += 1;
            studentPages = arr[i];
        }
    }
    return students;
}

int findPages(vector<int>& arr, int n, int m) {
    if(m > n) return -1;
    int low = *max_element(arr.begin(), arr.end());
    int high = accumulate(arr.begin(), arr.end(), 0);
    while (low <= high) {
        int mid = (low + high) / 2;
        int students = cntStudents(arr, mid);
        if(students > m) low = mid + 1;
        else high = mid - 1;
    }
    return low;
}
```

### Time & Space Complexity

-   **Time Complexity:** `O(N * log(sum(arr) - max(arr) + 1))`\
-   **Space Complexity:** `O(1)`
