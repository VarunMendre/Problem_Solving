# Problem: Search in Rotated Sorted Array

## Problem Statement
There is an integer array `nums` sorted in ascending order (with distinct values).  
Before being passed to the function, `nums` is **possibly rotated** at an unknown index `k` (1 <= k < nums.length).  
The resulting array looks like `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`.  

Example:  
Original: `[0,1,2,4,5,6,7]`  
Rotated by 3 → `[4,5,6,7,0,1,2]`  

Given this rotated array `nums` and an integer `target`, return the index of `target` if it exists, otherwise return `-1`.  
The algorithm must run in **O(log n)** time.  

---

## Brute Force Solution

### 1. Intuition / Approach
We simply iterate over the array and check each element.  
If the element matches the target, return its index. Otherwise, return `-1`.  

### 2. Dry Run
Input: `nums = [4,5,6,7,0,1,2], target = 0`  
- Traverse one by one → found `0` at index 4.  
Output = `4`.  

### 3. Code
```cpp
int search(vector<int>& nums, int target) {
    for(int i = 0; i < nums.size(); i++) {
        if(nums[i] == target) return i;
    }
    return -1;
}
```

### 4. Time & Space Complexity
- **Time Complexity**: O(n) (linear scan).  
- **Space Complexity**: O(1).  

---

## Optimal Solution (Binary Search)

### 1. Intuition / Approach
We use a **modified binary search** to handle rotation:
- At each step, check if the `mid` element is the target.  
- Determine which half is sorted:
  - If `nums[low] <= nums[mid]`, then the **left half is sorted**.  
    - If the target lies within this range, move to the left.  
    - Otherwise, search in the right half.  
  - Else, the **right half is sorted**.  
    - If the target lies within this range, move to the right.  
    - Otherwise, search in the left half.  

This ensures we always halve the search space, maintaining **O(log n)** complexity.

### 2. Dry Run
Input: `nums = [4,5,6,7,0,1,2], target = 0`  
- low=0, high=6, mid=3 → nums[3]=7 ≠ target.  
- Left half [4,5,6,7] is sorted, but target 0 is not in range → move right.  
- low=4, high=6, mid=5 → nums[5]=1 ≠ target.  
- Right half [1,2] is sorted, but target 0 not in range → move left.  
- low=4, high=4, mid=4 → nums[4]=0 = target → return 4.  

### 3. Code
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int low = 0, high = n - 1;
        while(low <= high) {
            int mid = (low + high) / 2;
            if(nums[mid] == target) return mid;
            if(nums[low] <= nums[mid]) {
                if(nums[low] <= target && target <= nums[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            } else {
                if(nums[mid] <= target && target <= nums[high]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }
        return -1;
    }
};
```

### 4. Time & Space Complexity
- **Time Complexity**: O(log n) (binary search).  
- **Space Complexity**: O(1).  
