# Problem: Search in Rotated Sorted Array - I

## Problem Statement
There is an integer array `nums` sorted in ascending order (with distinct values).  
Before being passed to the function, `nums` is **possibly rotated** at an unknown index `k` (1 <= k < nums.length).  
The resulting array looks like `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`.  

Example:  
Original: `[0,1,2,4,5,6,7]`  
Rotated by 3 â†’ `[4,5,6,7,0,1,2]`  

Given this rotated array `nums` and an integer `target`, return the index of `target` if it exists, otherwise return `-1`.  
The algorithm must run in **O(log n)** time.  

---

## Brute Force Solution

### 1. Intuition / Approach
We simply iterate over the array and check each element.  
If the element matches the target, return its index. Otherwise, return `-1`.  

### 2. Dry Run
Input: `nums = [4,5,6,7,0,1,2], target = 0`  
- Traverse one by one â†’ found `0` at index 4.  
Output = `4`.  

### 3. Code
```cpp
int search(vector<int>& nums, int target) {
    for(int i = 0; i < nums.size(); i++) {
        if(nums[i] == target) return i;
    }
    return -1;
}
```

### 4. Time & Space Complexity
- **Time Complexity**: O(n) (linear scan).  
- **Space Complexity**: O(1).  

---

## Optimal Solution (Binary Search)

### 1. Intuition / Approach
We use a **modified binary search** to handle rotation:
- At each step, check if the `mid` element is the target.  
- Determine which half is sorted:
  - If `nums[low] <= nums[mid]`, then the **left half is sorted**.  
    - If the target lies within this range, move to the left.  
    - Otherwise, search in the right half.  
  - Else, the **right half is sorted**.  
    - If the target lies within this range, move to the right.  
    - Otherwise, search in the left half.  

This ensures we always halve the search space, maintaining **O(log n)** complexity.

### 2. Dry Run
Input: `nums = [4,5,6,7,0,1,2], target = 0`  
- low=0, high=6, mid=3 â†’ nums[3]=7 â‰  target.  
- Left half [4,5,6,7] is sorted, but target 0 is not in range â†’ move right.  
- low=4, high=6, mid=5 â†’ nums[5]=1 â‰  target.  
- Right half [1,2] is sorted, but target 0 not in range â†’ move left.  
- low=4, high=4, mid=4 â†’ nums[4]=0 = target â†’ return 4.  

### 3. Code
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int low = 0, high = n - 1;
        while(low <= high) {
            int mid = (low + high) / 2;
            if(nums[mid] == target) return mid;
            if(nums[low] <= nums[mid]) {
                if(nums[low] <= target && target <= nums[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            } else {
                if(nums[mid] <= target && target <= nums[high]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }
        return -1;
    }

# Problem: Search in Rotated Sorted Array II

There is an integer array `nums` sorted in non-decreasing order (not necessarily with distinct values).  
Before being passed to your function, `nums` is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is  
`[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`.  

For example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index `5` and become `[4,5,6,6,7,0,1,2,4,4]`.  

Given the array `nums` after the rotation and an integer `target`, return `true` if target is in `nums`, otherwise return `false`.  

You must decrease the overall operation steps as much as possible.

---

## ðŸŸ¢ Brute Force Solution

### 1. Approach / Intuition
- Traverse the array linearly.
- Compare each element with the target.
- If found, return `true`. Otherwise, after the loop ends, return `false`.
- This approach doesnâ€™t use the sorted/rotated property of the array.

### 2. Dry Run
Input: `nums = [4,5,6,6,7,0,1,2,4,4], target = 0`  

Steps:  
- Compare `4` with `0` â†’ not equal  
- Compare `5` with `0` â†’ not equal  
- â€¦ continue until `nums[5] = 0` â†’ equal â†’ return `true`

### 3. Code
```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int n = nums.size();

        for(int i=0 ; i<n; i++) {
            if(nums[i] == target) return true;
        }
        return false;
    }
};
4. Time & Space Complexity
Time Complexity: O(n) â†’ we may need to check all elements.

Space Complexity: O(1) â†’ no extra space used.

ðŸ”µ Optimized (Better) Solution
1. Approach / Intuition
Use a modified binary search since the array is sorted & rotated.

Handle duplicates carefully:

If nums[low] == nums[mid] && nums[mid] == nums[high], we shrink the range (low++, high--) and continue.

Check which half is sorted:

If left half is sorted and target lies within it â†’ search left.

Otherwise, search right.

Similarly, if right half is sorted, decide based on targetâ€™s range.

2. Dry Run
Input: nums = [4,5,6,6,7,0,1,2,4,4], target = 0

low=0, high=9, mid=4 â†’ nums[4]=7
Left half sorted â†’ target not in [4,7] â†’ move right (low=5).

low=5, high=9, mid=7 â†’ nums[7]=2
Right half sorted â†’ target in [0,2] â†’ move left (high=6).

low=5, high=6, mid=5 â†’ nums[5]=0 â†’ found target â†’ return true.

3. Code
cpp
Copy code
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int n = nums.size();
        int low = 0, high = n - 1;
        while(low <= high) {
            int mid = (low + high) / 2;
            if(nums[mid] == target) return true;

            if(nums[low] == nums[mid] && nums[mid] == nums[high]) {
                low++, high--;
                continue;
            }

            if(nums[low] <= nums[mid]) {
                if(nums[low] <= target && target <= nums[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            } else {
                if(nums[mid] <= target && target <= nums[high]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }
        return false;
    }
};
4. Time & Space Complexity
Time Complexity:

Average case: O(log n) (binary search behavior).

Worst case (due to duplicates): O(n).

Space Complexity: O(1).
};
```

### 4. Time & Space Complexity
- **Time Complexity**: O(log n) (binary search).  
- **Space Complexity**: O(1).  
