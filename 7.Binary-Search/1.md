
# Binary Search Implementations

---

## Iterative Implementation

### Problem Statement
Implement Binary Search in an iterative way.

### 1. Approach / Intuition
We maintain two pointers, `low` and `high`, representing the current search range. At each step, we calculate the middle index, compare it with the target, and move either left or right depending on the comparison. This reduces the search space by half in every iteration.

### 2. Dry - Run
Example: nums = [1, 3, 5, 7, 9], target = 7

- low = 0, high = 4, mid = (0+4)/2 = 2 → nums[2] = 5 < 7 → move right → low = 3
- low = 3, high = 4, mid = (3+4)/2 = 3 → nums[3] = 7 → found at index 3.

### 3. Code
```cpp
int binarySearch(vector<int>& nums, int target) {
    int n = nums.size(); //size of the array
    int low = 0, high = n - 1;

    // Perform the steps:
    while (low <= high) {
        int mid = (low + high) / 2;
        if (nums[mid] == target) return mid;
        else if (target > nums[mid]) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}
```

### 4. Time & Space Complexity
- **Time Complexity:** O(log n)  
- **Space Complexity:** O(1)

### 5. Overflow or Edge Cases
- Edge case: Empty array → return -1  
- Overflow: `mid = (low + high) / 2` may cause overflow for large values. Use `mid = low + (high - low) / 2` to avoid.

---

## Recursive Implementation

### Problem Statement
Implement Binary Search using recursion.

### 1. Approach / Intuition
We use a recursive function that checks the middle element. If it’s equal to the target, return index. If the target is smaller, recurse on the left half, otherwise recurse on the right half. Base case is when `low > high`.

### 2. Dry - Run
Example: nums = [2, 4, 6, 8, 10], target = 8

- low = 0, high = 4, mid = 2 → nums[2] = 6 < 8 → recurse right (low=3, high=4)  
- low = 3, high = 4, mid = 3 → nums[3] = 8 → found at index 3.

### 3. Code
```cpp
class Solution {
private:
    int recursiveSearch(vector<int>& nums, int low, int high, int target) {
        if(low > high) return -1;
        int mid = (low + high) / 2;

        if(nums[mid] == target) return mid;
        else if(target > nums[mid]){
            return recursiveSearch(nums, mid + 1, high, target);
        } 
        return recursiveSearch(nums, low, mid - 1, target);
    }
public:
    int search(vector<int>& nums, int target) {
        return recursiveSearch(nums, 0, nums.size()-1, target);
    }
};
```

### 4. Time & Space Complexity
- **Time Complexity:** O(log n)  
- **Space Complexity:** O(log n) (due to recursion stack)

### 5. Overflow or Edge Cases
- Edge case: Empty array → return -1  
- Overflow: Same as iterative version → use `mid = low + (high - low) / 2`  
- Edge case: Recursion depth may cause stack overflow for extremely large arrays.
