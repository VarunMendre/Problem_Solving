# Problem 1: Square Root of a Number

## Problem Statement

You are given a positive integer `n`.\
Your task is to find and return its square root. If `n` is not a perfect
square, then return the floor value of sqrt(n).

------------------------------------------------------------------------

## Approach 1: Brute Force

### Intuition

The brute force approach tries every integer `i` starting from `0` up to
`n`.\
For each `i`, check if `i*i <= n`. The largest such `i` will be the
floor of the square root.

### Dry Run (Example: n = 10)

-   i = 0 → 0\*0 = 0 ≤ 10 → ans = 0\
-   i = 1 → 1\*1 = 1 ≤ 10 → ans = 1\
-   i = 2 → 2\*2 = 4 ≤ 10 → ans = 2\
-   i = 3 → 3\*3 = 9 ≤ 10 → ans = 3\
-   i = 4 → 4\*4 = 16 \> 10 → break\
    **Answer = 3**

### Code

``` cpp
int floorSqrt(int n) {
    int ans = 0;
    for (int i = 0; i < n; i++) {
        if ((i * i) <= n) {
            ans = i;
        } else {
            break;
        }
    }
    return ans;
}
```

### Time & Space Complexity

-   **Time:** O(n) (loop runs up to sqrt(n))\
-   **Space:** O(1)

------------------------------------------------------------------------

## Approach 2: Optimal (STL In-Built)

### Intuition

Use C++ STL `sqrt()` function which internally uses efficient
algorithms.\
Return its floor value.

### Dry Run (Example: n = 10)

-   sqrt(10) ≈ 3.16 → floor = 3

### Code

``` cpp
int floorSqrt(int n) {
    int ans = sqrt(n);
    return ans;
}
```

### Time & Space Complexity

-   **Time:** O(1)\
-   **Space:** O(1)

------------------------------------------------------------------------

## Approach 3: Binary Search

### Intuition

We know sqrt(n) lies between `1` and `n`.\
Use binary search to find the largest `mid` such that `mid*mid <= n`.

### Dry Run (Example: n = 10)

-   low=1, high=10\
-   mid=5 → 25 \> 10 → high=4\
-   mid=2 → 4 ≤ 10 → low=3\
-   mid=3 → 9 ≤ 10 → low=4\
-   mid=4 → 16 \> 10 → high=3\
    Loop ends, return high=3

### Code

``` cpp
int floorSqrt(int n) {
    int low = 1, high = n;
    while (low <= high) {
        long long mid = (low + high) / 2;
        long long val = mid * mid;
        if (val <= (long long)(n)) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return high;
}
```

### Time & Space Complexity

-   **Time:** O(log n)\
-   **Space:** O(1)

------------------------------------------------------------------------

# Problem 2: Nth Root of a Number

## Problem Statement

You are given two positive integers `n` and `m`.\
You have to return the `nth` root of `m`, i.e. `m^(1/n)`.\
If the `nth` root is not an integer, return -1.

Example:\
Input: `n=3`, `m=27`\
Output: `3`

------------------------------------------------------------------------

## Approach 1: Brute Force

### Intuition

Try every integer `i` starting from `0` to `m`.\
For each `i`, check if `i^n == m`.\
If yes, return `i`. If `i^n > m`, stop and return -1.

### Dry Run (Example: n=3, m=27)

-   i=0 → 0\^3 = 0 \< 27\
-   i=1 → 1\^3 = 1 \< 27\
-   i=2 → 2\^3 = 8 \< 27\
-   i=3 → 3\^3 = 27 = 27 → return 3

### Code

``` cpp
int f(int i, int n) {
  int ans = pow(i, n);
  return ans;
}

int NthRoot(int n, int m) {
  for (int i = 0; i < m; i++) {
    if (f(i, n) == m) {
      return i;
    } else if (f(i, n) > m) {
      break;
    }
  }
  return -1;
}
```

### Time & Space Complexity

-   **Time:** O(m \* log n) (since pow takes log n multiplications)\
-   **Space:** O(1)

------------------------------------------------------------------------

## Approach 2: Optimal (Binary Search)

### Intuition

We know the answer lies between `1` and `m`.\
Use binary search on this range.\
For each `mid`, compute `mid^n` using iterative multiplication to avoid
overflow.\
- If `mid^n == m` → return mid\
- If `mid^n < m` → move right (low=mid+1)\
- If `mid^n > m` → move left (high=mid-1)

### Dry Run (Example: n=3, m=27)

-   low=1, high=27\
-   mid=14 → 14\^3=2744 \> 27 → high=13\
-   mid=7 → 343 \> 27 → high=6\
-   mid=3 → 27 == 27 → return 3

### Code

``` cpp
int func(int mid, int n, int m) {
    long long ans = 1;
    for (int i = 1; i <= n; i++) {
        ans = ans * mid;
        if (ans > m) return 2;
    }
    if (ans == m) return 1;
    return 0;
}

int NthRoot(int n, int m) {
    int low = 1, high = m;
    while (low <= high) {
        int mid = (low + high) / 2;
        int midN = func(mid, n, m);
        if (midN == 1) {
            return mid;
        } else if (midN == 0) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;
}
```

### Time & Space Complexity

-   **Time:** O(log m \* n) (log m binary search steps × n
    multiplications per step)\
-   **Space:** O(1)
