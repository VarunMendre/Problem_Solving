# Problem: Kth Missing Positive Number

**Problem Statement:**\
Given an array `arr` of positive integers sorted in a strictly
increasing order, and an integer `k`.\
Return the kth positive integer that is missing from this array.

**Example:**\
Input: `arr = [2,3,4,7,11], k = 5`\
Output: `9`\
Explanation: The missing positive integers are
`[1,5,6,8,9,10,12,13,...]`.\
The 5th missing positive integer is `9`.

------------------------------------------------------------------------

## Brute Force Approach

### 1. Approach / Intuition

-   Start from the beginning of the array and check how many positive
    integers are missing.\
-   For each element `arr[i]`, if it is less than or equal to `k`,
    increment `k`.\
-   Finally, return `k` as the kth missing positive number.

### 2. Dry Run

Input: `arr = [2,3,4,7,11], k = 5`\
- i = 0 → arr\[0\] = 2 ≤ 5 → k = 6\
- i = 1 → arr\[1\] = 3 ≤ 6 → k = 7\
- i = 2 → arr\[2\] = 4 ≤ 7 → k = 8\
- i = 3 → arr\[3\] = 7 ≤ 8 → k = 9\
- i = 4 → arr\[4\] = 11 \> 9 → stop\
Answer = 9

### 3. Code

``` cpp
class Solution {
public:
    int findKthPositive(vector<int>& arr, int k) {
        int n = arr.size();
        for(int i = 0; i < n; i++) {
            if(arr[i] <= k) k++;
            else break;
        }
        return k;
    }
};
```

### 4. Time & Space Complexity

-   **Time Complexity:** O(N) (loop through array)\
-   **Space Complexity:** O(1)

------------------------------------------------------------------------

## Optimal Approach (Binary Search)

### 1. Approach / Intuition

-   Use binary search to find how many numbers are missing up to a
    certain index.\
-   Missing count at `mid` = `arr[mid] - (mid + 1)`\
-   If missing \< k → move right (low = mid + 1)\
-   Else → move left (high = mid - 1)\
-   Finally, answer = `k + high + 1`.

### 2. Dry Run

Input: `arr = [2,3,4,7,11], k = 5`\
- low = 0, high = 4\
- mid = 2 → arr\[2\] = 4 → missing = 4 - (2+1) = 1 \< 5 → low = 3\
- mid = 3 → arr\[3\] = 7 → missing = 7 - (3+1) = 3 \< 5 → low = 4\
- mid = 4 → arr\[4\] = 11 → missing = 11 - (4+1) = 6 ≥ 5 → high = 3\
Loop ends → high = 3\
Answer = k + high + 1 = 5 + 3 + 1 = 9

### 3. Code

``` cpp
class Solution {
public:
    int findKthPositive(vector<int>& arr, int k) {
        int n = arr.size();
        int low = 0, high = n - 1;
        while(low <= high) {
            int mid = (low + high) / 2;
            int missing = arr[mid] - (mid + 1);
            if(missing < k) low = mid + 1;
            else high = mid - 1;
        }
        return k + high + 1;
    }
};
```

### 4. Time & Space Complexity

-   **Time Complexity:** O(log N) (binary search)\
-   **Space Complexity:** O(1)
