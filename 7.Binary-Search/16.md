# Problem Explanations

------------------------------------------------------------------------

## Problem 1: Median of Two Sorted Arrays

**Problem Statement**\
Given two sorted arrays nums1 and nums2 of size m and n respectively,
return the median of the two sorted arrays.\
The overall run time complexity should be O(log(m+n)).

------------------------------------------------------------------------

### Brute Force Approach

**Intuition / Approach**\
- Merge both arrays into a single sorted array.\
- The median will be the middle element if the length is odd, or the
average of the two middle elements if even.

**Dry Run**\
nums1 = \[1, 3\], nums2 = \[2\]\
Merged = \[1, 2, 3\]\
Median = 2

**Code**

``` cpp
class Solution { 
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size(), n2 = nums2.size();
        vector<int> nums3;

        int i = 0, j = 0;

        while(i < n1 && j < n2) {
            if(nums1[i] < nums2[j])
                nums3.push_back(nums1[i++]);
            else
                nums3.push_back(nums2[j++]);    
        }
        while(i < n1) nums3.push_back(nums1[i++]);
        while(j < n2) nums3.push_back(nums2[j++]);

        int n = n1 + n2;
        if(n % 2 == 1) return (double)nums3[n/2];

        double median = ((double)nums3[n / 2] + (double) nums3[(n / 2) - 1])/ 2.0;
        return median;
    }
};
```

**Time Complexity:** O(n1 + n2)\
**Space Complexity:** O(n1 + n2)

------------------------------------------------------------------------

### Better Approach

**Intuition / Approach**\
- Instead of fully merging arrays, stop at the point where the median
element(s) are found.\
- This reduces unnecessary work.

**Dry Run**\
nums1 = \[1, 3\], nums2 = \[2, 4\]\
We only track elements until we reach middle index positions.

**Code**

``` cpp
double median(vector<int>& a, vector<int>& b) {
    int n1 = a.size(), n2 = b.size();
    int n = n1 + n2;
    int ind2 = n / 2;
    int ind1 = ind2 - 1;
    int cnt = 0;
    int ind1el = -1, ind2el = -1;

    int i = 0, j = 0;
    while (i < n1 && j < n2) {
        if (a[i] < b[j]) {
            if (cnt == ind1) ind1el = a[i];
            if (cnt == ind2) ind2el = a[i];
            cnt++; i++;
        } else {
            if (cnt == ind1) ind1el = b[j];
            if (cnt == ind2) ind2el = b[j];
            cnt++; j++;
        }
    }

    while (i < n1) {
        if (cnt == ind1) ind1el = a[i];
        if (cnt == ind2) ind2el = a[i];
        cnt++; i++;
    }
    while (j < n2) {
        if (cnt == ind1) ind1el = b[j];
        if (cnt == ind2) ind2el = b[j];
        cnt++; j++;
    }

    if (n % 2 == 1) return (double)ind2el;
    return (double)(ind1el + ind2el) / 2.0;
}
```

**Time Complexity:** O(n1 + n2)\
**Space Complexity:** O(1)

------------------------------------------------------------------------

### Optimal Approach (Binary Search)

**Intuition / Approach**\
- Use binary search on the smaller array to partition both arrays.\
- Ensure left half contains correct number of elements.\
- Median depends on max of left and min of right.

**Dry Run**\
nums1 = \[1, 3\], nums2 = \[2\]\
Partition: \[1\] \| \[3\] and \[2\] \| \[\]\
Median = max(1,2) = 2

**Code**

``` cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size(), n2 = nums2.size();
        if(n1 > n2) return findMedianSortedArrays(nums2, nums1);
        int low = 0, high = n1;
        int left = (n1 + n2 + 1) / 2;
        int n = n1 + n2;

        while(low <= high) {
            int mid1 = (low + high) >> 1;
            int mid2 = left - mid1;

            int l1 = INT_MIN, l2 = INT_MIN;
            int r1 = INT_MAX, r2 = INT_MAX;

            if(mid1 < n1) r1 = nums1[mid1];
            if(mid2 < n2) r2 = nums2[mid2];
            if(mid1 - 1 >= 0) l1 = nums1[mid1 - 1];
            if(mid2 - 1 >= 0) l2 = nums2[mid2 - 1];

            if(l1 <= r2 && l2 <= r1) {
                if(n % 2 == 1) return max(l1, l2);
                else return (double)(max(l1,l2)+ min(r1, r2))/2.0;
            } else if(l1 > r2) high = mid1 - 1;
            else low = mid1 + 1;
        }
        return 0;
    }
};
```

**Time Complexity:** O(log(min(n1, n2)))\
**Space Complexity:** O(1)

------------------------------------------------------------------------

## Problem 2: Kth Element of Two Sorted Arrays

**Problem Statement**\
You're given two sorted arrays 'arr1' and 'arr2' of size 'n' and 'm'
respectively and an element 'k'.\
Find the element that would be at the 'kth' position of the combined
sorted array.

------------------------------------------------------------------------

**Intuition / Approach**\
- Similar to the median problem, use binary search partitioning.\
- Ensure exactly `k` elements are in left partition.\
- Answer is the max of left partitions.

**Dry Run**\
arr1 = \[2, 3, 45\], arr2 = \[4, 6, 7, 8\], k=4\
Partitions -\> left = \[2,3,4,6\], right = \[7,8,45\]\
Answer = 6

**Code**

``` cpp
#include<bits/stdc++.h>
int kthElement(vector<int> &nums1, vector<int>& nums2, int n1, int n2, int k){
    if(n1 > n2) return kthElement(nums2, nums1, n2, n1, k);
    int low = max(0, k - n2), high = min(k , n1);
    int left = k;

    while(low <= high) {
        int mid1 = (low + high) >> 1;
        int mid2 = left - mid1;

        int l1 = INT_MIN, l2 = INT_MIN;
        int r1 = INT_MAX, r2 = INT_MAX;

        if(mid1 < n1) r1 = nums1[mid1];
        if(mid2 < n2) r2 = nums2[mid2];
        if(mid1 - 1 >= 0) l1 = nums1[mid1 - 1];
        if(mid2 - 1 >= 0) l2 = nums2[mid2 - 1];

        if(l1 <= r2 && l2 <= r1) {
            return max(l1, l2);
        } else if(l1 > r2) high = mid1 - 1;
        else low = mid1 + 1;
    }
    return 0;
}
```

**Time Complexity:** O(log(min(n1, n2)))\
**Space Complexity:** O(1)
