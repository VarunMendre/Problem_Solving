# Problem: Peak Element in Array

---

## Brute Force Approach

### Problem Statement
We are given an array `nums` of size `n`. A **peak element** is defined as an element that is strictly greater than its neighbors. 
- For the first element, it is a peak if it is greater than the second element.  
- For the last element, it is a peak if it is greater than the second last element.  
We need to return the index of any one peak element if it exists.

---

### 1. Approach / Intuition
- Traverse the entire array.  
- For each index `i`, check two conditions:  
  - If it is the first element, ensure it's greater than its next element.  
  - If it is the last element, ensure it's greater than its previous element.  
  - Otherwise, check if `nums[i]` is greater than both `nums[i-1]` and `nums[i+1]`.  
- If these conditions hold, return that index.  
- If no such element exists, return -1 (although at least one peak is always guaranteed in an array).

---

### 2. Dry Run

Example: `nums = [1, 2, 3, 1]`  

- i = 0 → (first element) → 1 < 2 → Not a peak  
- i = 1 → (check neighbors) → 2 < 3 → Not a peak  
- i = 2 → (check neighbors) → 3 > 2 and 3 > 1 → Peak found at index 2  

Answer: **2**

---

### 3. Code

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();

        for(int i = 0; i < n; i++) {
            if((i==0 || nums[i-1] < nums[i]) 
            && (i == n-1 || nums[i] > nums[i + 1])) {
                return i;
            }
        }
        return -1;
    }
};
```

---

### 4. Time & Space Complexity
- **Time Complexity:** O(N) → Iterates through the entire array.  
- **Space Complexity:** O(1) → Uses only constant extra space.  

---

## Optimal Approach (Binary Search)

### Problem Statement
Same as above: Find any peak element in the given array.

---

### 1. Approach / Intuition
- Instead of scanning linearly, we can leverage **binary search**:  
- Check mid element:
  - If `nums[mid]` is greater than both neighbors → It is a peak, return `mid`.  
  - If `nums[mid] > nums[mid - 1]`, then the right half may contain a peak → Move `low = mid + 1`.  
  - Else, the left half may contain a peak → Move `high = mid - 1`.  
- Edge cases:  
  - If `n == 1`, return 0.  
  - If first element > second → return 0.  
  - If last element > second last → return `n-1`.  

---

### 2. Dry Run

Example: `nums = [1, 2, 3, 1]`  

- Initial: low = 1, high = 2  
- mid = (1 + 2) / 2 = 1  
  - nums[1] = 2  
  - nums[1] < nums[2] → Move right → low = 2  
- Now mid = 2  
  - nums[2] = 3  
  - nums[2] > nums[1] && nums[2] > nums[3] → Peak found at index 2  

Answer: **2**

---

### 3. Code

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();
        if(n == 1) return 0;
        if(nums[0] > nums[1]) return 0;
        if(nums[n -1] > nums[n - 2]) return n - 1;

        int low = 1, high = n - 2;

        while(low <= high) {
            int mid = (low + high) / 2;

            if(nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) 
                    return mid;

            else if(nums[mid] > nums[mid - 1]) 
                    low = mid + 1;
            else 
                high = mid - 1;
        }

        return -1;
    }
};
```

---

### 4. Time & Space Complexity
- **Time Complexity:** O(log N) → Uses binary search to reduce search space.  
- **Space Complexity:** O(1) → Constant space usage.  

---
