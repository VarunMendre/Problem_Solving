# Problem 1: Find the Smallest Divisor Given a Threshold

## Problem Statement

Given an array of integers nums and an integer threshold, we will choose
a positive integer divisor, divide all the array by it, and sum the
division's result. Find the smallest divisor such that the result
mentioned above is less than or equal to threshold.

Each result of the division is rounded to the nearest integer greater
than or equal to that element.\
The test cases are generated so that there will be an answer.

### Example:

**Input:** nums = \[1,2,5,9\], threshold = 6\
**Output:** 5

Explanation:\
- Divisor = 1 → sum = 17\
- Divisor = 4 → sum = 7\
- Divisor = 5 → sum = 5 (valid answer)

------------------------------------------------------------------------

## 1. Approach / Intuition

-   The problem can be solved using **Binary Search** on the range of
    possible divisors (from 1 to max(nums)).\
-   For each divisor candidate, compute the sum of ceilings.\
-   If the sum is within the threshold, try smaller divisors. Otherwise,
    increase divisor.

------------------------------------------------------------------------

## 2. Dry Run

nums = \[1,2,5,9\], threshold = 6\
- low = 1, high = 9\
- mid = 5 → sum = 5 (valid, try smaller)\
- high = 4\
- mid = 2 → sum = 10 (too large, increase divisor)\
- low = 3\
- mid = 3 → sum = 7 (too large)\
- low = 4\
- mid = 4 → sum = 7 (too large)\
- low = 5

Answer = 5

------------------------------------------------------------------------

## 3. Code

``` cpp
class Solution {
private:
    int sumByDivi(vector<int>& nums, int div) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) {
            sum += ceil((double)(nums[i]) / (double)(div));
        }
        return sum;
    }
public:
    int smallestDivisor(vector<int>& nums, int threshold) {
        int low = 1, high = *max_element(nums.begin(), nums.end());
        while (low <= high) {
            int mid = (low + high) / 2;
            if (sumByDivi(nums, mid) <= threshold) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
};
```

------------------------------------------------------------------------

## 4. Time & Space Complexity

-   **Time Complexity:** O(N \* log(max(nums)))\
-   **Space Complexity:** O(1)

------------------------------------------------------------------------

# Problem 2: Capacity To Ship Packages Within D Days

## Problem Statement

A conveyor belt has packages that must be shipped from one port to
another within **D** days.\
The ith package has weight `weights[i]`. Each day, we load the ship with
packages in order, without exceeding max ship capacity.\
Return the least weight capacity of the ship to ship all packages within
D days.

------------------------------------------------------------------------

## Brute Force Approach

### 1. Approach / Intuition

-   Try every capacity between `max(weights)` and `sum(weights)`.
-   For each capacity, simulate number of days required using helper
    function.

### 2. Dry Run

weights = \[1,2,3,1,1\], D = 4\
- max = 3, sum = 8\
- cap = 3 → days = 3 (valid)\
- cap = 4 → days = 3 (valid)\
- cap = 5 → days = 2 (too few)\
Answer = 3

### 3. Code

``` cpp
int findDays(vector<int> &weights, int cap) {
    int days = 1, load = 0;
    for (int i = 0; i < weights.size(); i++) {
        if (load + weights[i] > cap) {
            days++;
            load = weights[i];
        }
        else load += weights[i];
    }
    return days;
}

int leastWeightCapacity(vector<int> &weights, int d) {
    int maxi = *max_element(weights.begin(), weights.end());
    int sum = accumulate(weights.begin(), weights.end(), 0);
    for (int i = maxi; i <= sum; i++) {
        if (findDays(weights, i) <= d) return i;
    }
    return -1;
}
```

### 4. Time & Space Complexity

-   **Time Complexity:** O(N \* (sum(weights) - max(weights) + 1))\
-   **Space Complexity:** O(1)

------------------------------------------------------------------------

## Optimal Approach (Binary Search)

### 1. Approach / Intuition

-   Instead of linear search, use **Binary Search** between max and
    sum.\
-   Check feasibility of each mid capacity.\
-   Adjust search space based on days needed.

### 2. Dry Run

weights = \[1,2,3,1,1\], D = 4\
- low = 3, high = 8\
- mid = 5 → days = 2 (too small, increase low)\
- low = 6\
- mid = 6 → days = 2\
- low = 7\
- mid = 7 → days = 2\
- low = 8\
- mid = 8 → days = 2\
Answer = 3 (from earlier valid)

### 3. Code

``` cpp
class Solution {
private:
    int findDays(vector<int>& weights, int cap) {
        int days = 1, load = 0;
        for(int i = 0; i < weights.size(); i++) {
            if(load + weights[i] > cap) {
                days++;
                load = weights[i];
            }
            else load += weights[i];
        }
        return days;
    }
public:
    int shipWithinDays(vector<int>& weights, int days) {
        int low = *max_element(weights.begin(), weights.end());
        int high = accumulate(weights.begin(), weights.end(), 0);
        while(low <= high) {
            int mid = (low + high) / 2;
            int numberOfDays = findDays(weights, mid);
            if(numberOfDays <= days) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
};
```

### 4. Time & Space Complexity

-   **Time Complexity:** O(N \* log(sum(weights)))\
-   **Space Complexity:** O(1)
