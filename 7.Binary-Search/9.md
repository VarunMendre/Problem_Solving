# Problem: Koko Eating Bananas

## Problem Statement
Koko loves to eat bananas. There are `n` piles of bananas, where the `i-th` pile has `piles[i]` bananas. The guards have gone and will return in `h` hours.

Koko can decide her bananas-per-hour eating speed `k`. Each hour, she chooses **one pile** of bananas and eats up to `k` bananas from that pile. If the pile has fewer than `k` bananas, she eats all of them and does not eat more bananas in that hour.

Koko wants to eat all bananas before the guards return but also wants to eat as slowly as possible.  
The task is to **return the minimum integer `k` (bananas/hour) such that she can finish all bananas within `h` hours**.

---

## 1. Approach / Intuition

This problem is a classic **search on answer** type, which can be solved using **Binary Search**.

- The eating speed `k` can range from:
  - **1** (slowest possible speed)
  - to **max(piles)** (fastest possible speed, since eating more than the max pile size per hour is unnecessary).

- For a given speed `k`, we can **simulate** the process:
  - Each pile of bananas `p` takes `ceil(p / k)` hours to eat completely.
  - Summing this across all piles gives the **total hours needed**.

- If the total hours `<= h`, then `k` is a valid speed, but we try to minimize it by searching left (`high = mid - 1`).  
- Otherwise, if total hours `> h`, then the speed is too slow, so we search right (`low = mid + 1`).

This forms the basis of **Binary Search** to find the minimum speed.

---

## 2. Dry Run

### Example:
```
piles = [3, 6, 7, 11], h = 8
```

- `low = 1`, `high = 11` (max pile).
- **Binary Search Iterations:**

1. `mid = (1 + 11) // 2 = 6`
   - Hours = ceil(3/6) + ceil(6/6) + ceil(7/6) + ceil(11/6)
   - = 1 + 1 + 2 + 2 = 6 hours
   - 6 ≤ 8 ✅ valid → search left → `high = 5`

2. `mid = (1 + 5) // 2 = 3`
   - Hours = ceil(3/3) + ceil(6/3) + ceil(7/3) + ceil(11/3)
   - = 1 + 2 + 3 + 4 = 10 hours
   - 10 > 8 ❌ too slow → search right → `low = 4`

3. `mid = (4 + 5) // 2 = 4`
   - Hours = ceil(3/4) + ceil(6/4) + ceil(7/4) + ceil(11/4)
   - = 1 + 2 + 2 + 3 = 8 hours
   - 8 ≤ 8 ✅ valid → search left → `high = 3`

Loop ends, answer = `low = 4`.

### Output:
```
Minimum eating speed = 4
```

---

## 3. Code

```cpp
class Solution {
private:
    int findMax(vector<int> &v) {
        int maxi = INT_MIN;
        for (int x : v) {
            maxi = max(maxi, x);
        }
        return maxi;
    }

    long long calculateTotalHours(vector<int> &v, long long hourly) {
        long long totalH = 0;
        for (int bananas : v) {
            totalH += (bananas + hourly - 1) / hourly;  // ceil division
        }
        return totalH;
    }

public:
    int minEatingSpeed(vector<int>& piles, int h) {
        long long low = 1, high = findMax(piles);

        while (low <= high) {
            long long mid = low + (high - low) / 2;  // ✅ safe from overflow
            long long totalHrs = calculateTotalHours(piles, mid);

            if (totalHrs <= h) {
                high = mid - 1; // try smaller k
            } else {
                low = mid + 1; // need larger k
            }
        }
        return (int)low; // minimum k
    }
};
```

---

## 4. Time and Space Complexity

- **Time Complexity:**  
  - Finding max pile → `O(n)`  
  - Each binary search step requires iterating over all piles → `O(n)`  
  - Binary search runs in `O(log(max(piles)))` steps.  
  - **Total = O(n · log(max(piles)))**

- **Space Complexity:**  
  - Only variables used, no extra data structures.  
  - **O(1)**
