# Problem: Minimum Number of Days to Make m Bouquets

You are given an integer array `bloomDay`, an integer `m` and an integer
`k`.\
You want to make `m` bouquets. To make a bouquet, you need to use `k`
adjacent flowers from the garden.\
The garden consists of `n` flowers, the `i-th` flower will bloom in
`bloomDay[i]` and then can be used in exactly one bouquet.\
Return the minimum number of days you need to wait to be able to make
`m` bouquets from the garden. If it is impossible to make `m` bouquets
return `-1`.

------------------------------------------------------------------------

## Brute Force Approach

### 1. Approach / Intuition

-   The brute force solution checks each possible day starting from the
    minimum bloom day to the maximum bloom day.\
-   For each day, it checks whether it is possible to make `m` bouquets
    by counting how many adjacent groups of `k` flowers have bloomed.\
-   If possible, return the current day; otherwise, keep checking.\
-   If no day works, return `-1`.

### 2. Dry Run

Consider `bloomDay = [1, 10, 3, 10, 2]`, `m = 3`, `k = 1`\
- Minimum = 1, Maximum = 10\
- Day = 1 → Only flower 1 bloomed → Bouquets = 1 (not enough)\
- Day = 2 → Flowers 1 and 2 bloomed → Bouquets = 2 (not enough)\
- Day = 3 → Flowers 1, 3, 5 bloomed → Bouquets = 3 ✅ → Answer = 3.

### 3. Code

``` cpp
bool possible(vector<int> &arr, int day, int m, int k) {
    int n = arr.size();
    int cnt = 0;
    int noOfB = 0;

    for (int i = 0; i < n; i++) {
        if (arr[i] <= day) {
            cnt++;
        } else {
            noOfB += (cnt / k);
            cnt = 0;
        }
    }
    noOfB += (cnt / k);
    return noOfB >= m;
}

int roseGarden(vector<int> arr, int k, int m) {
    long long val = m * 1ll * k * 1ll;
    int n = arr.size();
    if (val > n) return -1;

    int mini = INT_MAX, maxi = INT_MIN;
    for (int i = 0; i < n; i++) {
        mini = min(mini, arr[i]);
        maxi = max(maxi, arr[i]);
    }

    for (int i = mini; i <= maxi; i++) {
        if (possible(arr, i, m, k))
            return i;
    }
    return -1;
}
```

### 4. Time & Space Complexity

-   **Time Complexity:** `O((max(arr) - min(arr) + 1) * N)`\
    (Looping through each possible day and checking feasibility each
    time).\
-   **Space Complexity:** `O(1)`

------------------------------------------------------------------------

## Optimal Approach (Binary Search)

### 1. Approach / Intuition

-   Instead of checking each day sequentially, we use **binary search**
    between the minimum and maximum bloom days.\
-   For each mid value, check if it is possible to form `m` bouquets.\
-   If yes, try smaller days (left half); otherwise, try larger days
    (right half).\
-   This reduces the search time drastically.

### 2. Dry Run

Using the same example: `bloomDay = [1, 10, 3, 10, 2]`, `m = 3`,
`k = 1`\
- Minimum = 1, Maximum = 10\
- mid = 5 → Possible (bouquets = 4) → Move left\
- mid = 3 → Possible (bouquets = 3) → Move left\
- mid = 2 → Not possible → Move right\
- Answer = 3.

### 3. Code

``` cpp
class Solution {
private:
    bool isPossible(vector<int>& bloomDay, int days, int m, int k) {
        int cnt = 0, noOfBouquets = 0;
        int n = bloomDay.size();

        for(int i = 0; i < n; i++) {
            if(bloomDay[i] <= days) {
                cnt++;
            } else {
                noOfBouquets += (cnt / k);
                cnt = 0;
            }
        }
        noOfBouquets += (cnt / k);
        return noOfBouquets >= m;
    }

public:
    int minDays(vector<int>& bloomDay, int m, int k) {
        long long val = 1LL * m * k;
        if(val > bloomDay.size()) return -1;

        int mini = INT_MAX, maxi = INT_MIN;
        for(int i = 0; i < bloomDay.size(); i++) {
            mini = min(bloomDay[i], mini);
            maxi = max(bloomDay[i], maxi);
        }

        int low = mini, high = maxi;
        while(low <= high) {
            int mid = (low + high) / 2;
            if(isPossible(bloomDay, mid, m, k)) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
};
```

### 4. Time & Space Complexity

-   **Time Complexity:** `O(N * log(max - min + 1))`\
    (Binary search + checking feasibility each time).\
-   **Space Complexity:** `O(1)`
