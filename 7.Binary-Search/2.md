# Binary Search Variants -- Detailed Explanations

This document explains multiple problems based on **binary search
techniques** in depth.\
For each problem, we provide:

1.  Problem Statement\
2.  Approach / Intuition\
3.  Dry Run\
4.  Code\
5.  Time & Space Complexity

------------------------------------------------------------------------

## 1. Lower Bound

### Problem Statement

Given a sorted array `arr` of size `n` and an integer `x`, find the
**lower bound** of `x`.\
The **lower bound** is defined as the index of the **first element
greater than or equal to `x`** in the array.\
If no such element exists, return `n`.

------------------------------------------------------------------------

### Approach / Intuition

-   Since the array is sorted, binary search can be used.\
-   Keep a variable `ans` initialized to `n` (default case when all
    elements are smaller than `x`).\
-   If `arr[mid] >= x`, this could be the answer, but there may be a
    smaller index that also satisfies the condition → move left
    (`high = mid - 1`).\
-   Otherwise, move right (`low = mid + 1`).\
-   Continue until the search space is exhausted.

------------------------------------------------------------------------

### Dry Run

    arr = [1, 2, 4, 6, 8], x = 5, n = 5

    low = 0, high = 4, ans = 5

    mid = 2 → arr[2] = 4 < 5 → low = 3
    mid = 3 → arr[3] = 6 >= 5 → ans = 3, high = 2

    End → ans = 3

So, the lower bound of `5` is index `3` (element `6`).

------------------------------------------------------------------------

### Code

``` cpp
int lowerBound(vector<int> arr, int n, int x) {
    int low = 0, high = n - 1;
    int ans = n;

    while (low <= high) {
        int mid = (low + high) / 2;

        if (arr[mid] >= x) {
            ans = mid;
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return ans;
}
```

------------------------------------------------------------------------

### Time & Space Complexity

-   **Time:** `O(log n)` → Binary search divides the range in half each
    step.\
-   **Space:** `O(1)` → Only variables are used.

------------------------------------------------------------------------

## 2. Upper Bound

### Problem Statement

Given a sorted array `arr` of size `n` and an integer `x`, find the
**upper bound** of `x`.\
The **upper bound** is defined as the index of the **first element
strictly greater than `x`**.\
If no such element exists, return `n`.

------------------------------------------------------------------------

### Approach / Intuition

-   Similar to lower bound but with a strict condition.\
-   Keep `ans = n`.\
-   If `arr[mid] > x`, store `ans = mid` and search left.\
-   Otherwise (`arr[mid] <= x`), move right.\
-   Continue until the range ends.

------------------------------------------------------------------------

### Dry Run

    arr = [1, 2, 4, 6, 8], x = 6

    low = 0, high = 4, ans = 5

    mid = 2 → arr[2] = 4 <= 6 → low = 3
    mid = 3 → arr[3] = 6 <= 6 → low = 4
    mid = 4 → arr[4] = 8 > 6 → ans = 4, high = 3

    End → ans = 4

So, the upper bound of `6` is index `4` (element `8`).

------------------------------------------------------------------------

### Code

``` cpp
int upperBound(vector<int> &arr, int x, int n) {
    int low = 0, high = n - 1;
    int ans = n;

    while (low <= high) {
        int mid = (low + high) / 2;

        if (arr[mid] > x) {
            ans = mid;
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return ans;
}
```

------------------------------------------------------------------------

### Time & Space Complexity

-   **Time:** `O(log n)`\
-   **Space:** `O(1)`

------------------------------------------------------------------------

## 3. Search Insert Position

### Problem Statement

Given a sorted array `nums` of size `n` and an integer `x`, return the
**index where `x` should be inserted** in order to maintain the sorted
order.\
If `x` is already present, return its index.

------------------------------------------------------------------------

### Approach / Intuition

-   This problem is essentially finding the **lower bound**.\
-   Initialize `ans = n`.\
-   If `nums[mid] >= x`, update `ans = mid` and move left.\
-   Otherwise, move right.\
-   Finally, `ans` will hold the correct index.

------------------------------------------------------------------------

### Dry Run

    nums = [1, 3, 5, 6], x = 5

    low = 0, high = 3, ans = 4

    mid = 1 → nums[1] = 3 < 5 → low = 2
    mid = 2 → nums[2] = 5 >= 5 → ans = 2, high = 1

    End → ans = 2

So, the insert position is index `2`.

------------------------------------------------------------------------

### Code

``` cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int x) {
        int n = nums.size();
        int low = 0, high = n - 1;
        int ans = n;

        while (low <= high) {
            int mid = (low + high) / 2;

            if (nums[mid] >= x) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return ans;
    }
};
```

------------------------------------------------------------------------

### Time & Space Complexity

-   **Time:** `O(log n)`\
-   **Space:** `O(1)`

------------------------------------------------------------------------

## 4. Floor and Ceil

### Problem Statement

Given a sorted array `arr` of size `n` and an integer `x`, find the
**floor** and **ceil** of `x`.

-   **Floor:** largest element ≤ `x`.\
-   **Ceil:** smallest element ≥ `x`.\
    If not found, return `-1`.

------------------------------------------------------------------------

### Approach / Intuition

-   Use binary search to narrow down the range.\
-   If `arr[mid] == x`, both floor and ceil are `x`.\
-   If `arr[mid] < x`, update `floor = arr[mid]` and move right.\
-   If `arr[mid] > x`, update `ceil = arr[mid]` and move left.\
-   Continue until search ends.

------------------------------------------------------------------------

### Dry Run

    arr = [2, 4, 6, 8, 10], x = 7

    low = 0, high = 4
    mid = 2 → arr[2] = 6 < 7 → floor = 6, low = 3
    mid = 3 → arr[3] = 8 > 7 → ceil = 8, high = 2

    End → floor = 6, ceil = 8

------------------------------------------------------------------------

### Code

``` cpp
pair<int, int> getFloorAndCeil(vector<int> &arr, int n, int x) {
    int floorVal = -1, ceilVal = -1;
    int low = 0, high = n - 1;

    while (low <= high) {
        int mid = (low + high) / 2;

        if (arr[mid] == x) {
            floorVal = arr[mid];
            ceilVal = arr[mid];
            return {floorVal, ceilVal};
        } else if (arr[mid] < x) {
            floorVal = arr[mid];
            low = mid + 1;
        } else {
            ceilVal = arr[mid];
            high = mid - 1;
        }
    }
    return {floorVal, ceilVal};
}
```

------------------------------------------------------------------------

### Time & Space Complexity

-   **Time:** `O(log n)` → Binary search.\
-   **Space:** `O(1)` → Only constant variables are used.

------------------------------------------------------------------------
