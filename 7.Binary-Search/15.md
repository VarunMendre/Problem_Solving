# Minimize Maximum Distance of Gas Stations

------------------------------------------------------------------------

## Problem Statement

We are given an array `arr[]` where each element represents the position
of a gas station along a highway.\
We want to **add `k` more gas stations** such that the **maximum
distance between any two consecutive gas stations is minimized**.\
The task is to return the minimized maximum distance.

------------------------------------------------------------------------

# 1. Brute Force Approach

### Intuition / Approach

-   We track how many new stations we have placed in each segment
    (between two existing stations).\
-   At each step, we place a gas station in the segment which currently
    has the largest distance (after considering already added
    stations).\
-   Repeat this `k` times.\
-   Finally, the answer will be the maximum section length after all
    placements.

### Dry Run

For example:\
`arr = [1, 13, 17, 23], k = 5`

-   Initial segments: \[12, 4, 6\]\
-   Iteration 1: Place in 12 → splits into 6 & 6\
-   Iteration 2: Place in 6 (from 6,6,4,6) → becomes 3 & 3\
-   Iteration 3: Place in another 6 → becomes 3 & 3\
-   Iteration 4: Place in 4 → becomes 2 & 2\
-   Iteration 5: Place in remaining 6 → becomes 3 & 3

Final max section = 3.

### Code

``` cpp
double minimiseMaxDistance(vector<int> &arr, int k){
    int n = arr.size();
    vector<int> howMany(n-1, 0);

    for(int gasStation = 1; gasStation <= k; gasStation++) {
        long double maxSection = -1;
        int maxInd = -1;

        for(int i = 0; i < n-1; i++) {
            long double diff =( arr[i + 1] - arr[i]);
            long double sectionLength = diff / (long double) (howMany[i] + 1);

            if(sectionLength > maxSection) {
                maxSection = sectionLength;
                maxInd = i;
            } 
        }
        howMany[maxInd]++;
    }   

    long double maxAns = -1;
    for(int i = 0; i < n-1; i++) {
        long double diff = (arr[i+1] - arr[i]);
        long double sectionLength = diff / (long double) (howMany[i] + 1);
        maxAns = max(maxAns, sectionLength);
    }
    return maxAns;
}
```

### Complexity

-   **Time Complexity:** `O(k * n)` (for each new station, scanning all
    segments).\
-   **Space Complexity:** `O(n)` (extra array).

------------------------------------------------------------------------

# 2. Better Approach (Using Priority Queue)

### Intuition / Approach

-   Instead of scanning all segments repeatedly, we use a **max heap
    (priority queue)** to always pick the segment with the current
    largest distance.\
-   Each time we insert a station, we recalculate the new maximum
    section length and push it back into the heap.\
-   This reduces the need to scan all segments repeatedly.

### Dry Run

`arr = [1, 13, 17, 23], k = 5`\
- Push initial segments: (12, 4, 6).\
- Iteratively pop the largest, split it, push new values.\
- Finally, minimized maximum distance is computed.

### Code

``` cpp
#include<bits/stdc++.h>
double minimiseMaxDistance(vector<int> &arr, int k){
    int n = arr.size();
    vector<int> howMany(n-1, 0);
    priority_queue<pair<long double, int>>pq;

    for(int i = 0; i < n-1 ;i++) {
        pq.push({arr[i+1] - arr[i], i});
    }

    for(int gasStation = 1; gasStation <= k; gasStation++) {
        auto tp = pq.top(); pq.pop();
        int secInd = tp.second;

        howMany[secInd]++;

        long double iniDiff = arr[secInd + 1] - arr[secInd];
        long double newSecLen = iniDiff / (long double)(howMany[secInd] + 1);

        pq.push({newSecLen, secInd});
    }   
    return pq.top().first;
}
```

### Complexity

-   **Time Complexity:** `O(n log n) + O(k log n)`\
-   **Space Complexity:** `O(n)` (heap + extra array).

------------------------------------------------------------------------

# 3. Optimal Approach (Binary Search)

### Intuition / Approach

-   We binary search on the answer (max allowed distance).\
-   For a guessed distance `mid`, we check how many additional stations
    are required.\
-   If required stations `> k`, it means `mid` is too small → increase
    it.\
-   Otherwise, we can reduce `mid`.\
-   Continue until precision `1e-6`.

### Helper Function

``` cpp
int numberOfGasStationsRequired(long double dist, vector<int> &arr) {
    int n = arr.size();
    int cnt = 0;
    for (int i = 1; i < n; i++) {
        int numberInBetween = ((arr[i] - arr[i - 1]) / dist);
        if ((arr[i] - arr[i - 1]) == (dist * numberInBetween)) {
            numberInBetween--;
        }
        cnt += numberInBetween;
    }
    return cnt;
}
```

### Code

``` cpp
long double minimiseMaxDistance(vector<int> &arr, int k) {
    int n = arr.size();
    long double low = 0;
    long double high = 0;

    for (int i = 0; i < n - 1; i++) {
        high = max(high, (long double)(arr[i + 1] - arr[i]));
    }

    long double diff = 1e-6;
    while (high - low > diff) {
        long double mid = (low + high) / 2.0;
        int cnt = numberOfGasStationsRequired(mid, arr);
        if (cnt > k) {
            low = mid;
        }
        else {
            high = mid;
        }
    }
    return high;
}
```

### Complexity

-   **Time Complexity:** `O(n log(maxDist * 1e6))`\
-   **Space Complexity:** `O(1)`

------------------------------------------------------------------------
