# Problem Solving Explanations

## Problem 1: Row with Maximum Number of 1s

### Problem Statement

You have been given a non-empty grid `mat` with `n` rows and `m` columns
consisting of only 0s and 1s. All the rows are sorted in ascending
order.\
Your task is to find the index of the row with the maximum number of
ones.\
Note: If two rows have the same number of ones, consider the one with a
smaller index. If there's no row with at least 1 zero, return -1.

------------------------------------------------------------------------

### 1. Approach / Intuition

-   Since rows are sorted, we can use **binary search** to find the
    first occurrence of `1` in a row.
-   Once we get the index of the first `1`, the number of ones in that
    row is `m - index`.
-   Iterate through all rows, calculate the count of ones, and track the
    row with the maximum count.

------------------------------------------------------------------------

### 2. Dry Run

Matrix example:

    0 0 1 1
    0 1 1 1
    0 0 0 1

-   Row 0 → first `1` at index 2 → count = 2\
-   Row 1 → first `1` at index 1 → count = 3 (max so far)\
-   Row 2 → first `1` at index 3 → count = 1\
    Answer = Row 1

------------------------------------------------------------------------

### 3. Code

``` cpp
int lowerBound(vector<int> arr, int n, int x) {
    int low = 0, high = n - 1;
    int ans = n;

    while(low <= high) {
        int mid = (low + high) / 2;
        if(arr[mid] >= x) {
            ans = mid;
            high = mid - 1;
        }
        else {
            low = mid + 1;
        }
    }
    return ans;
}

int rowWithMax1s(vector<vector<int>> &matrix, int n, int m) {
    int cnt_max = 0;
    int index = -1;

    for(int i = 0; i < n; i++) {
        int cnt_ones = m - lowerBound(matrix[i], m, 1);

        if(cnt_ones > cnt_max) {
            cnt_max = cnt_ones;
            index = i;
        }
    }
    return index;
}
```

------------------------------------------------------------------------

### 4. Time & Space Complexity

-   **Time Complexity**: O(N \* logM)\
-   **Space Complexity**: O(1)

------------------------------------------------------------------------

## Problem 2: Search a 2D Matrix

### Problem Statement

You are given an m x n integer matrix with the following properties: 1.
Each row is sorted in non-decreasing order. 2. The first integer of each
row is greater than the last integer of the previous row.

Given an integer target, return `true` if target is in matrix or `false`
otherwise.\
You must write a solution in **O(log(m \* n))** time.

------------------------------------------------------------------------

### Brute Force

#### 1. Approach / Intuition

-   Traverse the entire matrix element by element.\
-   If any element matches the target, return `true`.\
-   Otherwise, return `false`.

#### 2. Dry Run

Matrix:

    1 3 5
    7 9 11
    13 15 17

Target = 9\
- Traverse row 0 → not found\
- Traverse row 1 → element at index \[1\]\[1\] = 9 → found

#### 3. Code

``` cpp
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int n = matrix.size(), m = matrix[0].size();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (matrix[i][j] == target)
                return true;
        }
    }
    return false;
}
```

#### 4. Time & Space Complexity

-   **Time Complexity**: O(N \* M)\
-   **Space Complexity**: O(1)

------------------------------------------------------------------------

### Better

#### 1. Approach / Intuition

-   Instead of traversing every element, check if the target lies in a
    particular row using boundaries.\
-   Apply binary search in that row.

#### 2. Dry Run

Matrix:

    1 3 5
    7 9 11
    13 15 17

Target = 15\
- Row 0: 1--5 → not in range\
- Row 1: 7--11 → not in range\
- Row 2: 13--17 → apply binary search → found at index \[2\]\[1\]

#### 3. Code

``` cpp
class Solution {
private:
    bool binarySearch(vector<int>&arr, int target){
        int low = 0, high = arr.size() - 1;
        while(low <= high) {
            int mid = (low + high) / 2;
            if(arr[mid] < target) low = mid + 1;
            else if(arr[mid] > target) high = mid - 1;
            else return true;
        }
        return false;
    }
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size();
        int m = matrix[0].size();
        for(int i = 0; i < n; i++) {
            if(matrix[i][0] <= target && target <= matrix[i][m-1]) {
                return binarySearch(matrix[i], target);
            }
        }
        return false;
    }
};
```

#### 4. Time & Space Complexity

-   **Time Complexity**: O(N + logM)\
-   **Space Complexity**: O(1)

------------------------------------------------------------------------

### Optimal

#### 1. Approach / Intuition

-   Treat the matrix as a flattened 1D sorted array of size `n * m`.\
-   Apply binary search directly on this 1D view and map indices back to
    row and column.

#### 2. Dry Run

Matrix:

    1 3 5
    7 9 11
    13 15 17

Target = 11\
- low = 0, high = 8\
- mid = 4 → element = 9 → \< target\
- low = 5, high = 8\
- mid = 6 → element = 13 → \> target\
- low = 5, high = 5\
- mid = 5 → element = 11 → found

#### 3. Code

``` cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size();
        int m = matrix[0].size();
        int low = 0, high = (n * m) - 1;
        while(low <= high) {
            int mid = (low + high) / 2;
            int row = mid / m;
            int cols = mid % m;
            if(matrix[row][cols] == target) return true;
            else if(matrix[row][cols] < target) low = mid + 1;
            else high = mid - 1;
        }
        return false;
    }
};
```

#### 4. Time & Space Complexity

-   **Time Complexity**: O(log(n \* m))\
-   **Space Complexity**: O(1)
