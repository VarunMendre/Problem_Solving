# Bit Manipulation problems

This document explains common **Bit Manipulation problems** in a structured way:
1. **Problem**  
2. **Approach / Intuition**  
3. **Code**  
4. **Time & Space Complexity**

---

## 1. Check if the i-th Bit is Set or Not

### Problem
Given an integer `n` and an index `i`, determine whether the **i-th bit (0-based index)** of `n` is set (1) or not (0).

---

### Approach / Intuition (Brute Force)
- Convert the number into its binary representation.
- Store each bit in a string.
- Check the character at index `i`.
- If index exceeds the length, the bit is considered `0`.

---

### Code (Brute Force)
```cpp
class Solution {
public:
    bool checkIthBit(int n, int i) {
        string binary = "";
        
        while (n > 0) {
            binary += (n % 2 == 0 ? '0' : '1');
            n /= 2;
        }

        if (i >= binary.size()) return false;
        return binary[i] == '1';
    }
};
```

### Time & Space Complexity
- **Time Complexity:** O(log n)
- **Space Complexity:** O(log n)

---

### Approach / Intuition (Optimal)
- Use a bitmask `1 << i` to isolate the i-th bit.
- Perform bitwise AND with `n`.
- If the result is non-zero, the bit is set.

---

### Code (Optimal)
```cpp
class Solution {
public:
    bool checkIthBit(int n, int i) {
        return (n & (1 << i)) != 0;
    }
};
```

### Time & Space Complexity
- **Time Complexity:** O(1)
- **Space Complexity:** O(1)

---

## 2. Check if a Number is Odd or Not

### Problem
Determine whether a given number `n` is **odd**.

---

### Approach / Intuition (Brute Force)
- If `n % 2 != 0`, the number is odd.

---

### Code (Brute Force)
```cpp
class Solution {
public:
    bool isOdd(int n) {
        return (n % 2 != 0);
    }
};
```

### Time & Space Complexity
- **Time Complexity:** O(1)
- **Space Complexity:** O(1)

---

### Approach / Intuition (Optimal)
- The least significant bit (LSB) determines odd/even.
- If `(n & 1) == 1`, the number is odd.

---

### Code (Optimal)
```cpp
return (n & 1);
```

### Time & Space Complexity
- **Time Complexity:** O(1)
- **Space Complexity:** O(1)

---

## 3. Count the Number of Set Bits

### Problem
Count the total number of `1`s in the binary representation of a number `n`.

---

### Approach / Intuition
- Use **Brian Kernighanâ€™s Algorithm**.
- Repeatedly turn off the rightmost set bit using `n & (n - 1)`.
- Count how many times this operation is performed.

---

### Code
```cpp
class Solution {
public:
    int countSetBits(int n) {
        int count = 0;
        while (n) {
            n &= (n - 1);
            count++;
        }
        return count;
    }
};
```

### Time & Space Complexity
- **Time Complexity:** O(number of set bits)
- **Space Complexity:** O(1)

---

## 4. Set the Rightmost Unset Bit

### Problem
Set the **rightmost unset (0) bit** of a given number `n`.

---

### Approach / Intuition
- Adding 1 flips the rightmost `0` bit and resets trailing `1`s.
- OR operation ensures the bit remains set.

---

### Code
```cpp
int setRightmostUnsetBit(int n) {
    return n | (n + 1);
}
```

### Time & Space Complexity
- **Time Complexity:** O(1)
- **Space Complexity:** O(1)

---

## 5. Swap Two Numbers Using XOR

### Problem
Swap two integers without using a temporary variable.

---

### Approach / Intuition
- XOR has the property: `a ^ a = 0` and `a ^ 0 = a`.
- Using three XOR operations, values can be swapped safely.

---

### Code
```cpp
void swapXOR(int &a, int &b) {
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
}
```

### Time & Space Complexity
- **Time Complexity:** O(1)
- **Space Complexity:** O(1)

---

## 6. Minimum Bit Flips to Convert One Number to Another

### Problem
Given two numbers `start` and `goal`, find the minimum number of bit flips required to convert `start` into `goal`.

---

### Approach / Intuition (Brute Force)
- XOR `start` and `goal` to find differing bits.
- Check each bit position manually.

---

### Code (Brute Force)
```cpp
class Solution {
public:
    int minBitFlips(int start, int goal) {
        int ans = start ^ goal;
        int cnt = 0;
        
        for(int i = 0; i < 31; i++) {
            if(ans & (1 << i)) cnt++;
        }
        return cnt;
    }
};
```

### Time & Space Complexity
- **Time Complexity:** O(31)
- **Space Complexity:** O(1)

---

### Approach / Intuition (Optimal)
- XOR highlights differing bits.
- Count set bits by checking the least significant bit repeatedly.

---

### Code (Optimal)
```cpp
class Solution {
public:
    int minBitFlips(int start, int goal) {
        int ans = start ^ goal;
        int cnt = 0;
        
        while(ans > 0) {
            cnt += ans & 1;
            ans >>= 1;
        }
        return cnt;
    }
};
```

### Time & Space Complexity
- **Time Complexity:** O(logâ‚‚(start ^ goal))
- **Space Complexity:** O(1)

---

### âœ… Key Takeaway
Bit manipulation allows **constant-time optimizations** and is heavily tested in **DSA interviews and competitive programming**. Mastering these patterns is essential in your **A2Z DSA Journey** ðŸš€

