# Bit Manipulation Problems â€“ Inâ€‘Depth Explanation

---

## ğŸ§© Problem 1: Subsets (Using Bit Masking)

### 1ï¸âƒ£ Algorithm / Intuition
- Any array of size **N** has **2^N** subsets.
- Each subset can be represented using a **binary number of length N**.
- If the **i-th bit is set**, include `nums[i]` in the subset.
- Iterate from `0 â†’ (2^N - 1)` and generate subsets using bit checks.

---

### 2ï¸âƒ£ Dry Run
Input: `nums = [1, 2, 3]`

Binary representation:
```
000 â†’ []
001 â†’ [1]
010 â†’ [2]
011 â†’ [1,2]
100 â†’ [3]
101 â†’ [1,3]
110 â†’ [2,3]
111 â†’ [1,2,3]
```

Each binary number decides which elements are picked.

---

### 3ï¸âƒ£ Code
```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        int subsets = 1 << n;
        vector<vector<int>> ans;

        for (int num = 0; num < subsets; num++) {
            vector<int> list;
            for (int i = 0; i < n; i++) {
                if (num & (1 << i))
                    list.push_back(nums[i]);
            }
            ans.push_back(list);
        }
        return ans;
    }
};
```

---

### 4ï¸âƒ£ Time & Space Complexity
- **Time Complexity:** `O(2^N * N)`
  - `2^N` subsets
  - `N` bit checks for each subset
- **Space Complexity:** `O(2^N * N)`
  - To store all subsets

---

## ğŸ§© Problem 2: Single Number (Every element appears twice)

### 1ï¸âƒ£ Algorithm / Intuition
- XOR properties:
  - `a ^ a = 0`
  - `a ^ 0 = a`
- XOR all elements â†’ duplicate numbers cancel out.
- The remaining value is the unique number.

---

### 2ï¸âƒ£ Dry Run
Input: `[4,1,2,1,2]`
```
ans = 0
0 ^ 4 = 4
4 ^ 1 = 5
5 ^ 2 = 7
7 ^ 1 = 6
6 ^ 2 = 4
```
Output = `4`

---

### 3ï¸âƒ£ Code
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (int i = 0; i < nums.size(); i++) {
            ans ^= nums[i];
        }
        return ans;
    }
};
```

---

### 4ï¸âƒ£ Time & Space Complexity
- **Time Complexity:** `O(N)`
- **Space Complexity:** `O(1)`

---

## ğŸ§© Problem 3: Single Number II (Every element appears 3 times)

---

### ğŸ”¹ Approach 1: Brute Force (Hash Map)

#### Algorithm
- Store frequency of each number.
- Return number with frequency = 1.

#### Code
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int, int> mpp;
        for(int num : nums) mpp[num]++;
        for(auto it : mpp) {
            if(it.second == 1) return it.first;
        }
        return 0;
    }
};
```

#### Complexity
- **Time:** `O(2N)`
- **Space:** `O(N)`

---

### ğŸ”¹ Approach 2: Better (Bit Counting)

#### Algorithm / Intuition
- Count set bits at each position (0â€“31).
- If count % 3 == 1 â†’ that bit belongs to the answer.
- Rebuild the number bitâ€‘byâ€‘bit.

---

#### Dry Run
Example: `[2,2,3,2]`
- Bits of 3 appear **1 time**, others appear **3 times**.
- Modulo operation filters out repeated numbers.

---

#### Code
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for(int bitInd = 0; bitInd < 31; bitInd++) {
            int cnt = 0;
            for(int num : nums) {
                if(num & (1 << bitInd)) cnt++;
            }
            if(cnt % 3 == 1) ans |= (1 << bitInd);
        }
        return ans;
    }
};
```

---

#### Complexity
- **Time:** `O(N * 32)` â‰ˆ `O(N)`
- **Space:** `O(1)`

---

### ğŸ”¹ Approach 3: Optimal (Sorting)

#### Algorithm
- Sort the array.
- Every number appears in a group of 3.
- The first mismatch gives the answer.

---

#### Code
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for(int i = 1; i < nums.size(); i += 3) {
            if(nums[i-1] != nums[i]) return nums[i-1];
        }
        return nums.back();
    }
};
```

---

#### Complexity
- **Time:** `O(N log N)`
- **Space:** `O(1)` (ignoring sort stack)

---

## âœ… Key Takeaways
- Bit manipulation removes extra space usage.
- XOR is extremely powerful for uniqueness problems.
- Bit counting generalizes XOR for repeated elements.

ğŸš€ *Perfect problems to strengthen lowâ€‘level thinking & interview prep!*

