## Problem 1: Count Good Numbers

### Explanation:
We need to count all possible strings of length **n**, such that:
- Digits at **even indices** (0, 2, 4, …) are **even digits** (0, 2, 4, 6, 8).
- Digits at **odd indices** (1, 3, 5, …) are **prime digits** (2, 3, 5, 7).

This problem demonstrates how recursion explores all possible combinations of valid digits at each index.

### Code:
```cpp
const int MOD = 1e9 + 7;

// Recursive function to count good numbers
int countGoodNumbers(int index, int n) {
    // Base case: when index reaches length n, we’ve formed one valid string
    if (index == n) {
        return 1;
    }

    int result = 0;

    // Even index → choose from even digits
    if (index % 2 == 0) {
        for (int digit : {0, 2, 4, 6, 8}) {
            result = (result + countGoodNumbers(index + 1, n)) % MOD;
        }
    }
    // Odd index → choose from prime digits
    else {
        for (int digit : {2, 3, 5, 7}) {
            result = (result + countGoodNumbers(index + 1, n)) % MOD;
        }
    }

    return result;
}
```

### Time Complexity:
- **O(2^n)** — because each position branches into multiple recursive calls.

### Space Complexity:
- **O(N)** — recursion depth proportional to the length of the string.

---

## Problem 2: Sort a Stack

### Explanation:
The goal is to sort a stack in **ascending order** using **recursion only**, without using any extra data structures.

Approach:
1. Remove the top element and recursively sort the remaining stack.
2. Insert the removed element back into the sorted stack at the correct position.

### Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

void insert(stack<int> &s, int temp) {
    if (s.empty() || s.top() < temp) {
        s.push(temp);
        return;
    }

    int val = s.top();
    s.pop();
    insert(s, temp);

    s.push(val);
}

void sortStack(stack<int> &stack) {
    if (!stack.empty()) {
        int temp = stack.top();
        stack.pop();

        sortStack(stack);

        insert(stack, temp);
    }
}
```

### Time Complexity:
- **O(N²)** — each recursive call may traverse the stack again for insertion.

### Space Complexity:
- **O(N)** — due to recursive call stack.

---

## Problem 3: Reverse a Stack

### Explanation:
We reverse a stack using recursion by removing the top element, reversing the rest, and inserting the removed element at the **bottom**.

### Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

void insertAtBottom(stack<int> &st, int val) {
    if (st.empty()) {
        st.push(val);
        return;
    }

    int topVal = st.top();
    st.pop();

    insertAtBottom(st, val);

    st.push(topVal);
}

void reverseStack(stack<int> &stack) {
    if (stack.empty()) return;

    int topVal = stack.top();
    stack.pop();

    reverseStack(stack);

    insertAtBottom(stack, topVal);
}
```

### Time Complexity:
- **O(N²)** — because for each element, insertion at the bottom takes O(N).

### Space Complexity:
- **O(N)** — recursive depth of N levels.

---

These three problems illustrate the **core recursive patterns** — breaking a problem into smaller subproblems, solving them recursively, and combining results elegantly without loops.