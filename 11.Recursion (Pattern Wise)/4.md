# Subsets (Power Set) — In-depth (4.md)

## Problem Statement
Given an integer array `nums` (no duplicates), return all possible subsets (the power set). The solution set must not contain duplicate subsets. You can return the result in any order.

This file explains two common approaches: **bitmask (iterative)** and **backtracking (recursive)**, with in-depth reasoning, dry-run examples, correctness, and complexity analysis.

---

## Approach 1 — Bitmask / Iterative (Naive)

### Idea
There are `2^n` possible subsets for an array of size `n`. Each subset corresponds to a bitmask of length `n` where bit `j` (0-indexed) indicates whether `nums[j]` is included (1) or excluded (0). Iterate masks from `0` to `(1<<n)-1` and build each subset by checking bits.

### Code
```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        int total = 1 << n;

        vector<vector<int>> result;

        for (int i = 0; i < total; i++) {
            vector<int> subset;
            for (int j = 0; j < n; j++) {
                if (i & (1 << j)) {
                    subset.push_back(nums[j]);
                }
            }
            result.push_back(subset);
        }

        return result;
    }
};
```

### Dry run (example)
Let `nums = [a, b, c]` (n=3). `total = 8`. Masks (binary) and subsets:
- `i=0` (000) → `[]`
- `i=1` (001) → `[a]` (bit0 set)
- `i=2` (010) → `[b]` (bit1 set)
- `i=3` (011) → `[a, b]`
- `i=4` (100) → `[c]`
- `i=5` (101) → `[a, c]`
- `i=6` (110) → `[b, c]`
- `i=7` (111) → `[a, b, c]`

Step-by-step for `i=5` (101): check j=0 → 1 -> include a; j=1 -> 0 -> skip b; j=2 -> 1 -> include c → subset [a,c].

### Correctness
Every integer from `0` to `2^n - 1` yields a unique combination of bits; therefore you enumerate all subsets exactly once. No duplicates because masks are unique.

### Complexity
- **Time:** O(n * 2^n) — for each of the `2^n` masks you scan `n` bits.  
- **Space:** O(n * 2^n) — result size (each subset stored) plus O(n) temporary subset (ignored in big-O for output)  

**When to use:** Straightforward, fast in practice for moderate n, and easy to implement.

---

## Approach 2 — Backtracking (Optimal / Standard)

### Idea
Build subsets incrementally: at index `ind` decide **not to include** `nums[ind]` (move to `ind+1`) *and* decide **to include** `nums[ind]` (add to current subset and recurse). This is a depth-first traversal of the subset decision tree. Use backtracking (undo the last choice) to restore state when returning from recursion.

### Code
```cpp
class Solution {
private: 
    void helper(vector<int>& nums, int ind, vector<int>& curr, vector<vector<int>>& result) {
        if (ind == nums.size()) {
            result.push_back(curr);
            return;
        }

        // Exclude nums[ind]
        helper(nums, ind + 1, curr, result);

        // Include nums[ind]
        curr.push_back(nums[ind]);
        helper(nums, ind + 1, curr, result);

        // Backtrack: remove last element
        curr.pop_back();
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> curr;
        helper(nums, 0, curr, result);
        return result;
    }
};
```

### Dry run (example)
`nums = [a, b, c]`.

Call tree (showing curr contents when pushed to result):

1. helper(ind=0, curr=[])
   - Exclude a → helper(ind=1, curr=[])
     - Exclude b → helper(ind=2, curr=[])
       - Exclude c → helper(ind=3, curr=[]) → push `[]`
       - Include c → curr=[c] → helper(ind=3) → push `[c]`; pop → curr=[]
     - Include b → curr=[b] → helper(ind=2)
       - Exclude c → push `[b]`
       - Include c → curr=[b,c] → push `[b,c]`; pop → curr=[b]
     - pop b → curr=[]
   - Include a → curr=[a] → helper(ind=1)
     - Exclude b → helper(ind=2, curr=[a])
       - Exclude c → push `[a]`
       - Include c → push `[a,c]`
     - Include b → curr=[a,b] → helper(ind=2)
       - Exclude c → push `[a,b]`
       - Include c → push `[a,b,c]`
     - pop b → curr=[a]
   - pop a

Order of results (one possible order): `[]`, `[c]`, `[b]`, `[b,c]`, `[a]`, `[a,c]`, `[a,b]`, `[a,b,c]`.

### Correctness
Backtracking systematically explores both choices (include/exclude) at each index, ensuring all `2^n` subsets are generated exactly once. `curr` carries the partial subset; copying it into `result` at the base case stores a snapshot.

### Complexity
- **Time:** O(2^n) in the sense of generating 2^n subsets, but each push/pop and copy of `curr` into result contributes; more precisely O(n * 2^n) accounting for copying subsets.  
- **Space:** O(n) recursion depth + output space O(n * 2^n).

**Why called optimal here:** Backtracking avoids scanning all n bits per subset explicitly — it only visits relevant branches and avoids bit-check loops; both approaches are similar asymptotically, but backtracking is more flexible (easy to add pruning, conditions, or constraints).

---

## Practical notes & variations
- If you need subsets of a specific size `k` (combinations), modify recursion to stop when `curr.size() == k` and avoid adding/removing beyond that.
- For arrays with duplicates and the requirement to avoid duplicate subsets, sort the array and skip duplicates during recursion (standard subset-with-duplicates pattern).
- Iterative building from existing subsets: start with `[[]]`, for every number `x`, append to current list of subsets new subsets formed by adding `x` to each existing subset — also common and intuitive.

---

## Example Code (Iterative expansion method)
```cpp
vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> res = {{}};
    for (int x : nums) {
        int sz = res.size();
        for (int i = 0; i < sz; ++i) {
            vector<int> temp = res[i];
            temp.push_back(x);
            res.push_back(temp);
        }
    }
    return res;
}
```

This method also runs in O(n * 2^n) time and is simple to implement when you want to avoid recursion.

---

## Summary
- Both bitmask and backtracking produce all subsets; both run in roughly O(n * 2^n) time when accounting for result copying.  
- Backtracking is more extensible for constraints (fixed-size subsets, avoid consecutive picks, skip duplicates).  
- Iterative bitmask is compact and fast for small n and when a direct enumeration is acceptable.

---

*Author: Varun Mendre*