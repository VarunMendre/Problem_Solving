# Subsets & Subsets II (Naive + Optimal + Dry Runs)

## Problem 1: Subsets

---

## âœ… **1. Naive (Bit Manipulation Method)**

### **Code:**
```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        int total = 1 << n;

        vector<vector<int>> result;

        for (int i = 0; i < total; i++) {
            vector<int> subset;
            for (int j = 0; j < n; j++) {
                if (i & (1 << j)) {
                    subset.push_back(nums[j]);
                }
            }
            result.push_back(subset);
        }

        return result;
    }
};
```

### **Time Complexity:**
- **O(N Ã— 2â¿)** â†’ because for each of the 2â¿ masks, we loop through N bits.

### **Space Complexity:**
- **O(N Ã— 2â¿)** output storage.

---

## ğŸ” Dry Run (nums = [1, 2, 3])
Total masks = 2Â³ = 8

| i (binary) | Subset |
|------------|--------|
| 000 | [] |
| 001 | [1] |
| 010 | [2] |
| 011 | [1, 2] |
| 100 | [3] |
| 101 | [1, 3] |
| 110 | [2, 3] |
| 111 | [1, 2, 3] |

---

## âœ… **2. Optimal (Recursive Backtracking)**

### **Code:**
```cpp
class Solution {
private:
    void helper(vector<int>& nums, int ind, vector<int>& curr, vector<vector<int>>& result) {
        if(ind == nums.size()) {
            result.push_back(curr);
            return;
        }

        helper(nums, ind + 1, curr, result);

        curr.push_back(nums[ind]);
        helper(nums, ind + 1, curr, result);
        curr.pop_back();
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> curr;

        helper(nums, 0, curr, result);
        return result;
    }
};
```

### **Time:** O(2â¿)
### **Space:** O(N) recursion stack

---

## ğŸ” Dry Run (nums = [1, 2])

### Recursion Tree:
```
                    []
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       Exclude               Include 1
         []                      [1]
       â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
   Ex(2)     In(2)       Ex(2)      In(2)
    []        [2]        [1]       [1,2]
```

Final subsets:
```
[], [2], [1], [1,2]
```

---
# Problem 2: Subsets II (Handling Duplicates)

## âœ… **1. Naive - Generate all + use set**

### Code:
```cpp
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        int n = nums.size();
        int total = 1 << n;

        set<vector<int>> result;

        for (int i = 0; i < total; i++) {
            vector<int> subset;
            for (int j = 0; j < n; j++) {
                if (i & (1 << j)) subset.push_back(nums[j]);
            }
            sort(subset.begin(), subset.end());
            result.insert(subset);
        }

        return vector<vector<int>>(result.begin(), result.end());
    }
};
```

### **Time Complexity:**
- Generating all subsets: **2â¿**
- Sorting each subset: **O(n log n)**
- Inserting in set: **O(log(2â¿)) = O(n)**

â¡ **Total: O(2â¿ Ã— n log n)**

### **Space Complexity:**
- **O(2â¿ Ã— n)** for storing results

---

## ğŸ” **Dry Run (nums = [1, 2, 2])**
All subsets before removing duplicates:
```
[], [1], [2], [1,2], [2], [1,2], [2,2], [1,2,2]
```
After sorting + set:
```
[], [1], [2], [1,2], [2,2], [1,2,2]
```

---

## âœ… **2. Optimal - Backtracking (Skip duplicates)**

### Code:
```cpp
class Solution {
private:
    void findSubsets(int ind, vector<int>& nums, vector<int>& ds, vector<vector<int>>& ans) {
        ans.push_back(ds);

        for(int i = ind; i < nums.size(); i++) {
            if(i != ind && nums[i] == nums[i-1]) continue;

            ds.push_back(nums[i]);
            findSubsets(i + 1, nums, ds, ans);
            ds.pop_back();
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> ans;
        vector<int> ds;
        sort(nums.begin(), nums.end());

        findSubsets(0, nums, ds, ans);
        return ans;
    }
};
```

### Time: **O(2â¿ Ã— n)**
### Space: **O(n)** recursion depth

---

## ğŸ” **Dry Run (nums = [1, 2, 2])**

### Recursion Tree:
```
Start: []

i = 0 â†’ take 1 â†’ [1]
    i = 1 â†’ take 2 â†’ [1,2]
        i = 2 â†’ take 2 â†’ [1,2,2]

Backtrackâ€¦

i = 1 â†’ take 2 â†’ [2]
    i = 2 â†’ skip duplicate (since nums[2] == nums[1])
```

Final result:
```
[], [1], [1,2], [1,2,2], [2]
```

---

# âœ… Summary Table

| Approach | Handles Duplicates? | Time | Space |
|---------|----------------------|------|--------|
| Subsets (Naive) | âŒ No | O(N Ã— 2â¿) | O(N Ã— 2â¿) |
| Subsets (Optimal) | âŒ No | O(2â¿) | O(N) |
| Subsets II (Naive) | âœ” Using Set | O(2â¿ Ã— n log n) | O(2â¿ Ã— n) |
| Subsets II (Optimal) | âœ” Yes | O(2â¿ Ã— n) | O(n) |

---

If you want, I can generate **6.md**, or add more recursion pattern problems!

