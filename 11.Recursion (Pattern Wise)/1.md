# âš¡ Problem: Power Function (POW x, n)

## ğŸ§© Problem Statement
Given two numbers **x** (a double) and **n** (an integer), you need to calculate and return **x raised to the power n**, i.e., \(x^n\).

This is a classic problem that tests understanding of **recursion**, **iteration**, and **mathematical optimization** using **exponentiation by squaring**.

---

## ğŸ”¹ Approach 1: Naive (Using Built-in Function)

### Code:
```cpp
class Solution {
public:
    double myPow(double x, int n) {
        return pow(x, n);
    }
};
```

### ğŸ” Explanation:
- Uses the built-in C++ `pow()` function directly.
- While easy, this approach doesnâ€™t demonstrate algorithmic understanding.

### â±ï¸ Time Complexity:
O(1) (since handled internally by the library)

### ğŸ’¾ Space Complexity:
O(1)

---

## ğŸ”¹ Approach 2: Iterative Multiplication

### Code:
```cpp
class Solution {
public:
    double myPow(double x, int n) {
        double ans = 1.0;
        long long power = n;

        if (power < 0) {
            x = 1 / x;
            power = -power;
        }

        for (int i = 0; i < power; i++) {
            ans *= x;
        }
        return ans;
    }
};
```

### ğŸ” Explanation:
- Handles **negative powers** by taking reciprocal of `x`.
- Uses a simple loop multiplying `x` `n` times.
- Inefficient for large `n` (e.g., 10^9).

### â±ï¸ Time Complexity:
O(n)

### ğŸ’¾ Space Complexity:
O(1)

### âš ï¸ Drawback:
For large values of `n`, this method is **slow** as it performs one multiplication per power.

---

## ğŸ”¹ Approach 3: Optimal (Exponentiation by Squaring)

### Code:
```cpp
class Solution {
public:
    double myPow(double x, int n) {
        double ans = 1.0;
        long long nn = n;

        if (nn < 0)
            nn = -1 * nn;

        while (nn) {
            if (nn % 2) {          // If power is odd
                ans = ans * x;
                nn = nn - 1;
            } else {               // If power is even
                x = x * x;         // Square the base
                nn = nn / 2;       // Halve the power
            }
        }

        if (n < 0)
            ans = (double)(1.0) / (double)(ans);

        return ans;
    }
};
```

### ğŸ” Step-by-Step Intuition:
1. **Handle negative powers:**
   - Convert power to positive and take reciprocal at the end.
2. **Exponentiation by squaring:**
   - If power is even â†’ square the base and halve the power.
   - If power is odd â†’ multiply `ans` with `x` and decrease power by 1.
3. Repeat until power becomes zero.

### ğŸ§  Example Walkthrough:
**Input:** `x = 2.0`, `n = 10`

| Step | x | n | ans | Action |
|------|---|---|------|--------|
| 1 | 2 | 10 | 1 | n even â†’ x = 4, n = 5 |
| 2 | 4 | 5 | 1 | n odd â†’ ans = 4, n = 4 |
| 3 | 4 | 4 | 4 | n even â†’ x = 16, n = 2 |
| 4 | 16 | 2 | 4 | n even â†’ x = 256, n = 1 |
| 5 | 256 | 1 | 4 | n odd â†’ ans = 1024, n = 0 |

âœ… **Result:** 1024.0

### â±ï¸ Time Complexity:
O(log n) â€” because power reduces by half every iteration.

### ğŸ’¾ Space Complexity:
O(1)

---

## âš™ï¸ Summary Comparison
| Approach | Method | Time Complexity | Space Complexity | Remarks |
|-----------|---------|----------------|------------------|----------|
| 1 | Built-in `pow()` | O(1) | O(1) | No algorithmic control |
| 2 | Simple Iterative | O(n) | O(1) | Too slow for large n |
| 3 | Exponentiation by Squaring | O(log n) | O(1) | âœ… Most efficient |

---

## ğŸ§¾ Key Takeaways
- Always handle **negative powers** carefully.
- Exponentiation by squaring drastically reduces time.
- Avoid using built-in methods during interviewsâ€”show your logic.

