# N-Queens — Deep Explanation (Brute-force + Optimal)

This document covers two implementations of the classic **N-Queens** problem: a straightforward brute-force solution using an `isSafe` check, and an optimized solution that uses auxiliary arrays (`leftRow`, `upperDiagonal`, `lowerDiagonal`) to make safety checks O(1). For each implementation we provide:

1. Algorithm / Intuition
2. Dry run (step-by-step on a small `n`)
3. Full code
4. Time & space complexity — explained in depth

---

## Problem Recap
Place `n` queens on an `n × n` chessboard such that no two queens attack each other. Queens attack along the same row, column and both diagonals.

We will adopt the standard column-by-column backtracking approach: place exactly one queen per column and move to the next column recursively. This reduces search since each column must contain a queen.

---

# Implementation A — Brute-force safety check (`isSafe`)

### 1) Algorithm / Intuition
- We attempt to place queens column by column (from leftmost column 0 to column `n-1`).
- For a given column `col`, we try every row `row = 0..n-1` and ask: "Is it safe to place a queen at `(row, col)`?"
- The `isSafe` function checks three directions (only in the left side of the board because future columns are empty):
  - upper-left diagonal (decreasing row, decreasing col)
  - left row (same row, decreasing col)
  - lower-left diagonal (increasing row, decreasing col)
- If safe, place the queen (`board[row][col] = 'Q'`), recurse for `col+1`. After recursion backtrack by removing the queen.
- Base case: when `col == n`, we placed `n` queens successfully and we push the current board configuration into `ans`.

This approach is intuitive and concise, but `isSafe` does repeated scanning which costs O(n) per check.

---

### 2) Dry run (n = 4)
We'll show the key branching decisions. Board initially empty (rows 0..3, cols 0..3). Using (r,c) notation.

- Start `col = 0`:
  - Try `row = 0`: `isSafe(0,0)` → true (no queens yet). Place Q at (0,0). Recurse `col=1`.

- `col = 1` (with Q at (0,0)):
  - Try `row = 0`: `isSafe(0,1)` → false (same row left has Q at (0,0)).
  - Try `row = 1`: `isSafe(1,1)` → false (upper-left diag sees (0,0)).
  - Try `row = 2`: `isSafe(2,1)` → true. Place Q at (2,1). Recurse `col=2`.

- `col = 2` (Q at (0,0) and (2,1)):
  - Try `row = 0`: false (row conflict with (0,0)).
  - Try `row = 1`: false (upper-left diag conflict with (2,1)).
  - Try `row = 2`: false (row conflict with (2,1)).
  - Try `row = 3`: `isSafe(3,2)` → false (lower-left diag conflict with (2,1)).
  - No valid row → backtrack: remove Q at (2,1), continue trying other rows in previous column.

- Back to `col = 1`, after removing (2,1): try `row = 3`: `isSafe(3,1)` → true. Place Q at (3,1). Recurse `col = 2`.

- And so on — the algorithm explores possibilities, backtracking when dead ends occur. For n=4, two distinct solutions will be found and recorded.

This dry-run illustrates scanning in `isSafe` and backtracking when no rows work.

---

### 3) Code (Brute-force)
```cpp
class Solution {
private:
    bool isSafe(int row, int col, vector<string>& board, int n) {

        int duprow = row;
        int dupcol = col;
        // upper diagonal

        while (row >= 0 && col >= 0) {
            if (board[row][col] == 'Q')
                return false;
            row--;
            col--;
        }

        row = duprow;
        col = dupcol;

        while (col >= 0) {
            if (board[row][col] == 'Q')
                return false;
            col--;
        }

         row = duprow;
        col = dupcol;

        while (row < n &&  col >= 0) {
            if (board[row][col] == 'Q')
                return false;
            row++;
            col--;
        }

        return true;
    }
    void solve(int col, vector<string>& board, vector<vector<string>>& ans,
               int n) {
        if (col == n) {
            ans.push_back(board);
            return;
        }

        for (int rows = 0; rows < n; rows++) {
            if (isSafe(rows, col, board, n)) {
                board[rows][col] = 'Q';
                solve(col + 1, board, ans, n);
                board[rows][col] = '.';
            }
        }
    }

public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ans;
        vector<string> board(n);

        string s(n, '.');
        for (int i = 0; i < n; i++) {
            board[i] = s;
        }

        solve(0, board, ans, n);

        return ans;
    }
};
```

---

### 4) Time & Space Complexity (Brute-force) — In-depth

**Time Complexity:** `O(N × N!)` (commonly described as `O(N! × N)`)

**Why N! factor?**
- We place one queen per column, and in the worst case the branching factor is approximately the number of remaining rows that are not yet used. A rough upper bound of the number of leaf nodes (complete placements) is N × (N-1) × (N-2) × ... × 1 = N! (each column chooses a distinct row). While pruning reduces this in practice, the theoretical search space is factorial.

**Why multiply by N?**
- For each attempted placement at position (row,col), `isSafe` scans up to O(N) cells (checking upper-left diag, left row, lower-left diag). These O(N) checks happen at each recursive placement/attempt.

So the total is O(N! × N).

**Space Complexity:** `O(N^2)`

- Board representation uses `N×N` characters (vector of strings). If we consider output storage, storing all solutions takes O(#solutions × N^2) but the auxiliary working memory is O(N^2) for the board.
- Recursion depth is N (one call per column) — O(N) auxiliary stack.

If we count only auxiliary memory excluding final outputs and the board used to create outputs, the extra space is O(N) (recursion + small variables). But typical interview answers include the board so O(N^2) is appropriate.

---

# Implementation B — Optimized using arrays (O(1) safety checks)

In this version we avoid scanning the board to check safety by maintaining three arrays:
- `leftRow[row]` — whether a queen exists in that row (for columns left of current).
- `upperDiagonal[index]` — whether a queen exists on an upper-left → lower-right diagonal. Indexing trick: for position (row,col) the upper-diagonal index is `(n-1) + (col - row)` so indices range `0..2n-2`.
- `lowerDiagonal[index]` — whether a queen exists on a lower-left → upper-right diagonal. Index for (row,col) is `row + col`.

Using these arrays we test safety in O(1) time by checking three integer arrays at those indices.

---

### 1) Algorithm / Intuition
- Place queens column by column as before.
- For a candidate (row,col) check if `leftRow[row] == 0` and `upperDiagonal[(n-1)+(col-row)] == 0` and `lowerDiagonal[row+col] == 0`. If all zero, it's safe.
- When placing a queen, set those 3 markers to 1; when backtracking, set them back to 0.
- This removes the O(N) scan per placement and makes safety check O(1).

---

### 2) Dry run (n = 4)
We'll simulate high-level steps (indices shown):

- Start `col=0` with arrays all zeros.
  - Try `row=0`: check `leftRow[0]==0` and `upperDiag[3+0-0]==upperDiag[3]==0` and `lowerDiag[0+0]==lowerDiag[0]==0` → safe. Place queen and set those markers: `leftRow[0]=1`,`upperDiag[3]=1`,`lowerDiag[0]=1`. Recurse col=1.

- `col=1`: try `row=0` → `leftRow[0]==1` → conflict, skip.
  - `row=1`: check `leftRow[1]==0`, `upperDiag[3 + 1 - 1] == upperDiag[3] == 1` → conflict (diagonal), skip.
  - `row=2`: all three indices zero? compute: `leftRow[2]==0`, `upperDiag[3 + 1 - 2] == upperDiag[2]==0`, `lowerDiag[2+1]==lowerDiag[3]==0` → safe. Place queen at (2,1) and mark arrays.

- `col=2`: continue similarly; at each candidate we check 3 array positions in O(1). Backtracking unmarks arrays.

This yields same solution set as brute-force but with much faster safety checks.

---

### 3) Code (Optimized)
```cpp
class Solution {
private:
    void solve(int col, vector<string>& board, vector<vector<string>>& ans,
               vector<int>& leftRow, vector<int>& upperDiagonal,
               vector<int>& lowerDiagonal, int n) {

        if (col == n) {
            ans.push_back(board);
            return;
        }

        for (int row = 0; row < n; row++) {
            if (leftRow[row] == 0 && upperDiagonal[n - 1 + col - row] == 0 &&
                lowerDiagonal[row + col] == 0) {
                board[row][col] = 'Q';
                leftRow[row]++;
                upperDiagonal[(n - 1) + (col - row)]++;
                lowerDiagonal[col + row]++;

                solve(col + 1, board, ans, leftRow, upperDiagonal,
                      lowerDiagonal, n);

                board[row][col] = '.';
                leftRow[row] = 0;
                upperDiagonal[(n - 1) + (col - row)] = 0;
                lowerDiagonal[row + col] = 0;
            }
        }
    }

public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ans;
        vector<string> board(n);

        string s(n, '.');
        for (int i = 0; i < n; i++) {
            board[i] = s;
        }

        vector<int> leftRow(n, 0), upperDiagonal(2 * n - 1, 0),
            lowerDiagonal(2 * n - 1, 0);
        solve(0, board, ans, leftRow, upperDiagonal, lowerDiagonal, n);

        return ans;
    }
};
```

---

### 4) Time & Space Complexity (Optimized) — In-depth

**Time Complexity:** `O(N!)` (factorial) — with constant-time safety checks instead of O(N) scans.

**Why factorial?**
- The backtracking still explores permutations of row placements across columns. In the worst case, the search space of leaf nodes that place one queen in every column is bounded by N × (N-1) × (N-2) × ... = N!.
- Each attempted placement now does O(1) work (3 array lookups + a few assignments), instead of O(N) scanning, so total cost becomes O(N!).

**Practical note:** Pruning reduces the search space dramatically (many branches cut early because of conflicts), so empirical runtime is far better than worst-case.

**Space Complexity:**
- If counting auxiliary memory (excluding output boards): O(N) for the three arrays + O(N) recursion depth → **O(N)**.
- If including the board used to construct solutions, O(N^2) for the board representation.

---

# Additional Discussion & Optimization Ideas

1. **Bitmasking:** For even faster checks and lower memory, we can represent `leftRow`, `upperDiagonal`, and `lowerDiagonal` as bitmasks in integers (or `long long`) and perform O(1) checks with bit operations. This reduces memory and can be faster in practice.

2. **Symmetry pruning:** For the N-Queens problem, you can reduce search by placing the queen in only half of the first row's positions and mirror solutions (for even n) because of board symmetry. This gives about 2× speedup but complicates code and solution listing.

3. **Counting only:** If you only need the number of solutions (not the actual boards), avoid maintaining the board strings — this reduces memory and can be a bit faster.

---

# Final Summary Table

| Version | Safety check | Time Complexity | Aux Space (excluding output) |
|---------|--------------|-----------------|------------------------------|
| Brute-force `isSafe` | O(N) scan | O(N! × N) | O(N) recursion (board O(N^2)) |
| Optimized arrays | O(1) checks | O(N!) | O(N) (arrays + recursion) |

---

*Author: Varun Mendre — Recursion & Backtracking notes*

