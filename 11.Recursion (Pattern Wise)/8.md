# Recursion & Backtracking â€” Palindrome Partitioning + Word Search

This file contains detailed explanations of:
- **Palindrome Partitioning** (Backtracking)
- **Word Search** (DFS + Backtracking)

---

# ğŸŸ¦ Palindrome Partitioning

### âœ… **Goal**
Given a string *s*, partition it such that **every substring** is a palindrome. Return *all* possible partitions.

---

## ğŸ” **Approach: Backtracking**
We try every possible substring starting at index `ind`:
1. Check if substring `s[ind â€¦ i]` is a **palindrome**.
2. If yes â†’ add to current list (`ds`), recurse.
3. On returning â†’ backtrack by removing last substring.

---

## ğŸ§  Key Function: `func(ind, s, ds, ans)`
- `ind` â†’ starting index to explore
- `ds` â†’ current partition (vector of palindromes)
- `ans` â†’ result list

### **Base Case**
```cpp
if (ind == s.size()) {
    ans.push_back(ds);
    return;
}
```
ğŸ‘‰ When `ind` reaches the end, we found a valid partition.

---

## ğŸ§ª Palindrome Check
Efficient 2-pointer check:
```cpp
while(start <= end) {
    if(s[start++] != s[end--]) return false;
}
return true;
```

---

## ğŸ“Œ Time & Space Complexity
| Notation | Meaning |
|---------|---------|
| **N** | Length of string |

### ğŸ•’ **Time Complexity: `O(2^N * N)`**
- Partitioning generates **all possible subsets** â†’ `O(2^N)`
- Each palindrome check costs **O(N)**.

### ğŸ§µ **Space Complexity: `O(2^N * N)`**
- Recursion + storing all partitions.

---

# ğŸŸ© Word Search (LeetCode Problem)

### âœ… **Goal**
Given a grid of characters and a word, check if the word exists using **adjacent cells** (up/down/left/right).

---

## ğŸ” **Approach: DFS + Backtracking**
Starting from every cell:
- Match the character
- Explore 4 directions
- Mark cell as visited (`'#'`), then revert later

### Important: We cannot reuse the same cell in a single path.

---

## ğŸ”§ DFS Logic
### Base Case
```cpp
if (ind == word.size()) return true;
```
ğŸ‘‰ If all characters matched â†’ word found.

### Boundary / Mismatch Check
Stops when:
- Out of grid
- Character mismatch
- Already visited cell

---

## âœ¨ Backtracking Step
```cpp
char temp = board[i][j];
board[i][j] = '#';
// DFS calls
board[i][j] = temp; // backtrack
```

---

## ğŸ“Œ Time & Space Complexity
Let:
- `m`, `n` = grid dimensions
- `L` = length of word

### ğŸ•’ **Time Complexity: `O(m*n * 4^L)`**
- Starting DFS from each cell â†’ `m*n`
- Each DFS can branch in 4 directions â†’ `4^L`

### ğŸ§µ **Space Complexity: `O(L)`**
- Maximum recursion depth = length of word

---

# âœ… Summary
| Problem | Technique | Key Idea | TC | SC |
|--------|-----------|----------|----|----|
| **Palindrome Partitioning** | Backtracking | Try all substrings, check palindrome | O(2^N * N) | O(2^N * N) |
| **Word Search** | DFS + Backtracking | Explore 4 directions, mark visited | O(m*n * 4^L) | O(L) |

---

Let me know if you want the **next questions**, more problems, or if you'd like me to add diagrams! ğŸš€

