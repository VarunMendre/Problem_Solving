
# ðŸ§© Problem Solving â€“ Recursion Patterns (5)

---

## ðŸ§® Problem 1: Count Subsequences with Target Sum

### ðŸ§  Intuition

This problem asks us to **count all possible subsequences** in an array that add up to a given target sum.

We use recursion to explore **two choices** for each element:
1. **Include** the current element in the sum.
2. **Exclude** it and move to the next element.

---

### ðŸ“˜ Code (Approach 1 â€“ Recursive Counting)

```cpp
class Solution {
private:
    int func(int ind, int sum, vector<int> &nums) {
        if (sum == 0) return 1;
        if (sum < 0 || ind == nums.size()) return 0;

        return func(ind + 1, sum - nums[ind], nums) + func(ind + 1, sum, nums);
    }

public:
    int countSubsequenceWithTargetSum(vector<int>& nums, int target) {
        return func(0, target, nums);
    }
};
```

---

### ðŸ’¡ Alternate Code (Same Logic Simplified)

```cpp
#include<bits/stdc++.h>
using namespace std;

int printS(int ind, int s, int sum, int arr[], int n ) {
    if(ind == n) {
        return s == sum;
    }

    s += arr[ind];
    int l = printS(ind+1, s, sum, arr, n);
    s -= arr[ind];
    int r = printS(ind+1, s, sum, arr, n);
     
    return l + r;
}

int main() {
    int arr[] = {1, 2, 1};
    int n = 3, sum = 2;
    cout << printS(0, 0, sum, arr, n);
}
```

---

### ðŸ§© Dry Run Example

**Input:** `arr = [1, 2, 1]`, `target = 2`

| Step | Index | Current Sum | Decision | Result |
|------|--------|--------------|-----------|---------|
| 0 | 0 | 0 | Include 1 â†’ sum=1 | â†’ Recurse |
| 1 | 1 | 1 | Include 2 â†’ sum=3 (Invalid) | 0 |
| 1 | 1 | 1 | Exclude 2 â†’ sum=1 | â†’ Recurse |
| 2 | 2 | 1 | Include 1 â†’ sum=2 âœ… | +1 |
| 2 | 2 | 1 | Exclude 1 â†’ sum=1 | 0 |

âœ… **Total subsequences = 2** â†’ `{1,1}` and `{2}`

---

### â±ï¸ Complexity

- **Time Complexity:** O(2â¿) (Each element has two choices)  
- **Space Complexity:** O(N) (Recursive stack)

---

## ðŸŽ¯ Problem 2: Combination Sum â€“ II

### ðŸ§  Intuition

We are asked to find **unique combinations** of numbers that sum up to a target.  
Unlike â€œCombination Sum I,â€ each number can be used **only once**, and duplicate combinations are **not allowed**.

To ensure uniqueness:
- We **sort** the array.
- Skip duplicate elements when iterating (`if (i > ind && arr[i] == arr[i-1]) continue`).

---

### ðŸ“˜ Code (Naive Approach â€“ Using Set)

```cpp
class Solution {
private:
    void findCombinations(int ind, int target, vector<int>& arr, set<vector<int>>& result, vector<int>& ds) {
        if (ind == arr.size()) {
            if (target == 0) result.insert(ds);
            return;
        }
        if (arr[ind] <= target) {
            ds.push_back(arr[ind]);
            findCombinations(ind, target - arr[ind], arr, result, ds);
            ds.pop_back();
        }
        findCombinations(ind + 1, target, arr, result, ds);
    }

public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        set<vector<int>> result;
        vector<int> ds;
        findCombinations(0, target, candidates, result, ds);
        return vector<vector<int>>(result.begin(), result.end());
    }
};
```

---

### âš¡ Optimal Code (Backtracking + Sorting)

```cpp
class Solution {
private: 
    void generateAllCombinations(int ind, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int>& ds) {
        if (target == 0) {
            ans.push_back(ds);
            return;
        }

        for (int i = ind; i < arr.size(); i++) {
            if (i > ind && arr[i] == arr[i-1]) continue;
            if (arr[i] > target) break;

            ds.push_back(arr[i]);
            generateAllCombinations(i + 1, target - arr[i], arr, ans, ds);
            ds.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        vector<vector<int>> ans;
        vector<int> ds;
        generateAllCombinations(0, target, candidates, ans, ds);
        return ans;
    }
};
```

---

### ðŸ§© Dry Run Example

**Input:** `candidates = [10,1,2,7,6,1,5]`, `target = 8`  
**Sorted:** `[1,1,2,5,6,7,10]`

| Step | i | Picked | Remaining Target | Action |
|------|---|--------|------------------|---------|
| 0 | 0 | [1] | 7 | Continue |
| 1 | 1 | [1,1] | 6 | Continue |
| 2 | 3 | [1,1,5] | 1 | Dead End |
| 3 | 4 | [1,1,6] | 0 âœ… | Save |
| 4 | Backtrack | [1] | 7 | Skip duplicates |
| 5 | 2 | [1,2] | 5 | Continue |
| 6 | 3 | [1,2,5] | 0 âœ… | Save |
| 7 | 4 | [1,2,6] | 1 | Dead End |
| 8 | 5 | [1,7] | 0 âœ… | Save |
| 9 | 3 | [2,6] | 0 âœ… | Save |

âœ… **Unique combinations:**  
`[[1,1,6], [1,2,5], [1,7], [2,6]]`

---

### â±ï¸ Complexity

- **Time Complexity:** O(2â¿ Ã— k) (k = avg combination length)  
- **Space Complexity:** O(k Ã— x) (x = number of valid combinations)

---

> ðŸš€ Both problems demonstrate how recursive backtracking efficiently explores combinations and subsets while controlling constraints like duplicates and sum limits.
