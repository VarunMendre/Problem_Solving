# ğŸ§® Count Subsequences with Target Sum

---

## ğŸ§  Problem Statement
Given an array `nums` and a target value `target`, count the number of subsequences whose **sum equals the target**.

---

## ğŸ’¡ C++ Solution 1 (Using Helper Function)
```cpp
class Solution {
private:
    int func(int ind, int sum, vector<int> &nums) {
        if (sum == 0) return 1;                  // âœ… Found one subsequence
        if (sum < 0 || ind == nums.size()) return 0;  // âŒ Invalid path

        // Include current element or skip it
        return func(ind + 1, sum - nums[ind], nums) + func(ind + 1, sum, nums);
    }

public:
    int countSubsequenceWithTargetSum(vector<int>& nums, int target) {
        return func(0, target, nums);
    }
};
```

---

## ğŸ’¡ C++ Solution 2 (Alternative Recursive Function)
```cpp
#include<bits/stdc++.h>
using namespace std;

int printS(int ind, int s, int sum, int arr[], int n ) {
    if(ind == n) {
        return (s == sum);
    }
    
    // Pick current element
    s += arr[ind];
    int left = printS(ind + 1, s, sum, arr, n);

    // Backtrack and skip current element
    s -= arr[ind];
    int right = printS(ind + 1, s, sum, arr, n);
     
    return left + right;
}

int main() {
    int arr[] = {1, 2, 1};
    int n = 3;
    int sum = 2;
    
    cout << printS(0, 0, sum, arr, n);
}
```

---

## ğŸªœ Dry Run Example

### Input:
```
arr = [1, 2, 1]
Target Sum = 2
```

### Recursive Tree (Simplified View):
```
                    (ind=0, s=0)
                    /         \
          +1â†’(1, s=1)         (1, s=0)
            /      \             /       \
   +2â†’(2, s=3)  (2, s=1)   +2â†’(2, s=2)   (2, s=0)
     |             |          |             |
   0 (no)      +1â†’(3,s=2)  +1â†’(3,s=3)   +1â†’(3,s=1)
                   âœ…yes
```

### âœ… Valid Subsequences:
- [1, 1] â†’ Sum = 2
- [2] â†’ Sum = 2

### ğŸ§¾ Output:
```
2
```

---

## â±ï¸ Time and Space Complexity
- **Time Complexity:** O(2^N) â€” Every element has two choices: include or exclude.
- **Space Complexity:** O(N) â€” Due to recursion stack depth.

---

## ğŸ§© Key Insights
- Recursion explores all possible combinations.
- Backtracking helps reset the state after each recursive call.
- Works well for small N; for large arrays, DP or memoization is preferred.

---

ğŸ“˜ **GitHub Reference:** [Problem_Solving - Recursion Pattern Wise #2](https://github.com/VarunMendre/Problem_Solving/blob/main/11.Recursion%20(Pattern%20Wise)/2.md)

