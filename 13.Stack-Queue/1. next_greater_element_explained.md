# Next Greater Element Problems ‚Äì Detailed Explanation

This document explains **Next Greater Element I** and **Next Greater Element II** in a clear **interview‚Äëready** manner. For **each problem**, the explanation follows this exact order:

1. **Approach / Intuition**
2. **Code**
3. **Time & Space Complexity**

---

## 1Ô∏è‚É£ Next Greater Element ‚Äì I (LeetCode 496)

### üîπ Approach / Intuition

- We are given two arrays:
  - `nums2` ‚Üí the reference array
  - `nums1` ‚Üí query array (subset of `nums2`)

- The task is to find the **next greater element of each element in `nums1`**, based on its position in `nums2`.

- A **monotonic decreasing stack** is used while traversing `nums2`:
  - If the current element is **greater than the stack top**, it becomes the **next greater element** for the stack top.
  - We store this mapping in a **hash map** for fast lookup later.

- Once all next greater elements for `nums2` are computed:
  - We simply look up answers for `nums1` using the map.
  - If an element does not exist in the map, its answer is `-1`.

This ensures **efficient preprocessing + constant time queries**.

---

### üîπ Code

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> ng;
        stack<int> st;

        for (int num : nums2) {
            while (!st.empty() && st.top() < num) {
                ng[st.top()] = num;
                st.pop();
            }
            st.push(num);
        }

        vector<int> res;
        for (int num : nums1) {
            res.push_back(ng.count(num) ? ng[num] : -1);
        }

        return res;
    }
};
```

---

### üîπ Time & Space Complexity

- **Time Complexity:**
  - Traversing `nums2`: `O(N)`
  - Traversing `nums1`: `O(M)`
  - **Total:** `O(N + M)`

- **Space Complexity:**
  - Stack: `O(N)`
  - Hash Map: `O(N)`
  - Result array: `O(M)`
  - **Auxiliary Space:** `O(N)`

---

## 2Ô∏è‚É£ Next Greater Element ‚Äì II (Circular Array) (LeetCode 503)

### üîπ Approach / Intuition

- This is a **circular array** problem, meaning after the last element, the array continues from the beginning.

- To simulate circular behavior:
  - We iterate from `2N - 1` down to `0`
  - Access elements using `nums[i % n]`

- A **monotonic decreasing stack** is maintained:
  - While stack top is smaller or equal to the current element, pop it.
  - The next greater element is the current stack top (if it exists).

- Results are only filled during the **first N iterations** (`i < n`) to avoid overwriting.

This guarantees each element is processed efficiently while handling circularity.

---

### üîπ Code

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        int n = nums.size();
        stack<int> st;
        vector<int> nge(n);

        for (int i = 2 * n - 1; i >= 0; i--) {
            while (!st.empty() && st.top() <= nums[i % n]) {
                st.pop();
            }

            if (i < n) {
                nge[i] = st.empty() ? -1 : st.top();
            }

            st.push(nums[i % n]);
        }

        return nge;
    }
};
```

---

### üîπ Time & Space Complexity

- **Time Complexity:**
  - Loop runs `2N` times
  - Each element is pushed and popped **at most once**
  - **Total:** `O(2N)` ‚Üí `O(N)`

- **Space Complexity:**
  - Stack: `O(N)`
  - Result array: `O(N)`
  - **Auxiliary Space:** `O(N)`

---

## ‚úÖ Interview Notes

- **NGE I:** Uses stack + hashmap ‚Üí `O(N + M)`
- **NGE II:** Circular array ‚Üí requires `2N` traversal
- Stack operations are **amortized O(1)**
- Always clarify **which NGE problem** you are solving in interviews

---

üìå *This explanation format is optimized for interviews, revision notes, and markdown documentation.*

