# Merge Two Sorted Arrays

---

## Problem Statement

Given two sorted arrays `arr1` and `arr2` of sizes `n` and `m` respectively, merge them into a single sorted array without using extra space if possible.

---

## 1. Brute Force Approach

### Intuition / Approach

* Use a **third array** to merge both sorted arrays using two pointers.
* Copy back elements into the original arrays.
* Simple to implement but requires `O(n+m)` extra space.

### Algorithm

1. Initialize two pointers `left` (for `arr1`) and `right` (for `arr2`).
2. Compare elements and push the smaller one into `arr3`.
3. If one array is exhausted, copy the remaining elements of the other.
4. Copy back elements from `arr3` into `arr1` and `arr2`.

### Code

```cpp
void merge(long long arr1[], long long arr2[], int n, int m) {
    long long arr3[n + m];
    int left = 0, right = 0, index = 0;

    while (left < n && right < m) {
        if (arr1[left] <= arr2[right]) {
            arr3[index++] = arr1[left++];
        } else {
            arr3[index++] = arr2[right++];
        }
    }

    while (left < n) arr3[index++] = arr1[left++];
    while (right < m) arr3[index++] = arr2[right++];

    for (int i = 0; i < n + m; i++) {
        if (i < n) arr1[i] = arr3[i];
        else arr2[i - n] = arr3[i];
    }
}
```

### Time & Space Complexity

* **Time Complexity:** O(n + m).
* **Space Complexity:** O(n + m).

---

## 2. Optimal Approach (Gap Method)

### Intuition / Approach

* Avoid extra space by using the **gap method** (Shell Sort idea).
* Compare elements that are `gap` apart and swap if required.
* Reduce the gap after each pass until it becomes 1.
* Finally, copy elements from `nums2` into `nums1`â€™s extra slots.

### Algorithm

1. Set initial gap = ceil((n+m)/2).
2. Compare and swap elements at positions `left` and `right = left+gap` across `nums1` and `nums2`.
3. Reduce gap using gap = ceil(gap/2).
4. Repeat until gap becomes 1.
5. Copy all elements of `nums2` into the end of `nums1`.

### Code

```cpp
class Solution {
private:
    void swapIfGreater(vector<int>& nums1, vector<int>& nums2, int ind1, int ind2) {
        if (nums1[ind1] > nums2[ind2]) {
            swap(nums1[ind1], nums2[ind2]);
        }
    }

public:
    void merge(vector<int>& nums1, int n, vector<int>& nums2, int m) {
        int len = n + m;
        int gap = (len / 2) + (len % 2);

        while (gap > 0) {
            int left = 0, right = left + gap;
            while (right < len) {
                if (left < n && right >= n) {
                    swapIfGreater(nums1, nums2, left, right - n);
                } else if (left >= n) {
                    swapIfGreater(nums2, nums2, left - n, right - n);
                } else {
                    swapIfGreater(nums1, nums1, left, right);
                }
                left++, right++;
            }

            if (gap == 1) break;
            gap = (gap / 2) + (gap % 2);
        }

        for (int i = 0; i < m; i++) nums1[n + i] = nums2[i];
    }
};
```

### Time & Space Complexity

* **Time Complexity:** O((n+m) log(n+m)) due to gap reduction.
* **Space Complexity:** O(1) (in-place).
