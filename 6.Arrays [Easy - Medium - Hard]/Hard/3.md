# Problem Statement

**Three Sum Problem**:  
Given an integer array `nums`, return all the unique triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.  

The solution set must not contain duplicate triplets.

---

## **Brute Force Approach**

### 1. Intuition  
We check every possible triplet in the array to see if the sum is zero.  
Since we need unique triplets, we store them in a set after sorting each triplet to avoid permutations being counted as duplicates.

### 2. Algorithm / Approach  
1. Iterate over all possible combinations of three indices `(i, j, k)` where `i < j < k`.  
2. Check if `nums[i] + nums[j] + nums[k] == 0`.  
3. If yes, sort the triplet and insert it into a set to remove duplicates.  
4. Convert the set into a vector and return it.

### 3. Dry Run  
Example: nums = [-1, 0, 1, 2, -1, -4]  

- i=0, j=1, k=2 → sum = (-1) + 0 + 1 = 0 → store [-1, 0, 1]  
- i=0, j=1, k=3 → sum = (-1) + 0 + 2 = 1 → skip  
- i=0, j=2, k=4 → sum = (-1) + 1 + (-1) = -1 → skip  
- ... repeat until all triplets are checked.  

Final set = {[-1, 0, 1], [-1, -1, 2]}.

### 4. Code  
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        set<vector<int>> st;

        for(int i = 0; i < n; i++) {
            for(int j = i+1; j < n; j++) {
                for(int k = j+1; k < n; k++) {
                    if(nums[i] + nums[j] + nums[k] == 0) {
                        vector<int> temp = {nums[i], nums[j], nums[k]};
                        sort(temp.begin(), temp.end());
                        st.insert(temp);
                    }
                }
            }
        }

        vector<vector<int>> ans(st.begin(), st.end());
        return ans;
    }
};
```

### 5. Time & Space Complexity  
- **Time Complexity**:  
  - Triple nested loop: `O(N^3)`  
  - Sorting each triplet: `O(3 log 3)` (constant)  
  - Insertion into set: `O(log U)` where `U` is number of unique triplets  
  **Overall**: `O(N^3 * log U)`  

- **Space Complexity**:  
  - Set storage: `O(2 * U)` where `U` is number of unique triplets.

---

## **Better Approach**

### 1. Intuition  
Instead of three loops, we fix one number and use a hash set to find the other two numbers. This reduces complexity from `O(N^3)` to `O(N^2)`.

### 2. Algorithm / Approach  
1. Iterate over `i` from `0` to `n-1`.  
2. For each `i`, create a hash set.  
3. Iterate `j` from `i+1` to `n-1`.  
4. Calculate the required third number: `third = -(nums[i] + nums[j])`.  
5. If `third` exists in the hash set, store the sorted triplet in the set.  
6. Insert `nums[j]` into the hash set.  
7. Convert the set into a vector and return.

### 3. Dry Run  
Example: nums = [-1, 0, 1, 2, -1, -4]  

- i=0 → hashSet = {}  
  - j=1 → third = 1 → not found → insert 0  
  - j=2 → third = 0 → found → triplet [-1, 1, 0] → store sorted [-1, 0, 1]  
  - ... continue  

### 4. Code  
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        set<vector<int>> st;

        for(int i = 0; i < n; i++) {
            set<int> hashSet;
            for(int j = i+1; j < n; j++) {
                int third = -(nums[i] + nums[j]);
                if(hashSet.find(third) != hashSet.end()) {
                    vector<int> temp = {nums[i], nums[j], third};
                    sort(temp.begin(), temp.end());
                    st.insert(temp);
                }
                hashSet.insert(nums[j]);
            }
        }
        vector<vector<int>> ans(st.begin(), st.end());
        return ans;
    }
};
```

### 5. Time & Space Complexity  
- **Time Complexity**: `O(N^2 * log U)` (sorting triplets + set insertion).  
- **Space Complexity**: `O(N)` for hash set + `O(U)` for storing triplets.

---

## **Optimal Approach**

### 1. Intuition  
Sort the array and use a **two-pointer approach** to find triplets in `O(N^2)` without extra hash sets. This also avoids duplicates naturally.

### 2. Algorithm / Approach  
1. Sort the array.  
2. Iterate `i` from `0` to `n-1`.  
   - If `nums[i] == nums[i-1]`, skip to avoid duplicates.  
3. Set two pointers: `j = i+1`, `k = n-1`.  
4. While `j < k`:  
   - Calculate `sum = nums[i] + nums[j] + nums[k]`.  
   - If `sum > 0`, decrement `k`.  
   - If `sum < 0`, increment `j`.  
   - If `sum == 0`, store the triplet and move both pointers while skipping duplicates.

### 3. Dry Run  
Example: nums = [-1, 0, 1, 2, -1, -4]  
Sorted: [-4, -1, -1, 0, 1, 2]  

- i=0 (-4) → sum too small → move j  
- i=1 (-1) → find (0, 1) and (-1, 2) triplets  
- Avoid duplicates using skip condition.

### 4. Code  
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> ans;
        sort(nums.begin(), nums.end());

        for(int i = 0; i < n; i++) {
            if(i > 0 && nums[i] == nums[i - 1]) continue;

            int j = i+1;
            int k = n-1;

            while(j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                if(sum > 0) k--;
                else if(sum < 0) j++;
                else {
                    ans.push_back({nums[i], nums[j], nums[k]});
                    j++; k--;
                    while(j < k && nums[j] == nums[j - 1]) j++;
                    while(j < k && nums[k] == nums[k + 1]) k--;
                }
            }
        }
        return ans;
    }
};
```

### 5. Time & Space Complexity  
- **Time Complexity**:  
  - Sorting: `O(N log N)`  
  - Two-pointer search: `O(N^2)`  
  **Overall**: `O(N^2)`  

- **Space Complexity**:  
  - Output list: `O(U)` where `U` is number of unique triplets.
