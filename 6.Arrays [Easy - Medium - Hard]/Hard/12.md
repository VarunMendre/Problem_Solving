# Maximum Product Subarray Problem

## Problem Statement
You are given an integer array `nums`. Find the contiguous subarray within an array (containing at least one number) which has the **largest product** and return that product.

---

# Brute Force Solution

## 1. Intuition / Approach
The brute force approach tries **all possible subarrays** and calculates the product of each.  
- Start with every index `i`.  
- For each `j ≥ i`, calculate the product of subarray `nums[i..j]`.  
- Track the maximum product found so far.  

This solution is simple but very inefficient since it uses three nested loops.

## 2. Dry Run
Example: `nums = [2, 3, -2, 4]`

- Subarrays starting at `i=0`:  
  [2] → product = 2  
  [2,3] → product = 6 (max so far)  
  [2,3,-2] → product = -12  
  [2,3,-2,4] → product = -48  

- Subarrays starting at `i=1`:  
  [3] → product = 3  
  [3,-2] → product = -6  
  [3,-2,4] → product = -24  

- Subarrays starting at `i=2`:  
  [-2] → -2  
  [-2,4] → -8  

- Subarrays starting at `i=3`:  
  [4] → 4  

Maximum product = 6.

## 3. Code
```cpp
int maxProductSubArray(vector<int>& nums) {
    int result = INT_MIN;
    for(int i=0; i<nums.size()-1; i++) {
        for(int j=i+1; j<nums.size(); j++) {
            int prod = 1;
            for(int k=i; k<=j; k++) 
                prod *= nums[k];
            result = max(result, prod);
        }
    }
    return result;
}
```

## 4. Time & Space Complexity
- **Time Complexity:** O(N³) → three nested loops.  
- **Space Complexity:** O(1) → constant extra memory.  

---

# Better Solution

## 1. Intuition / Approach
Instead of recalculating product for every subarray using a third loop, we can maintain the product **incrementally**.  
- Fix `i` as the starting index.  
- Multiply elements sequentially as `j` moves from `i` to end.  
- Update maximum product at each step.  

This avoids the innermost loop.

## 2. Dry Run
Example: `nums = [2, 3, -2, 4]`

- i=0:  
  p=2 → max=2  
  p=2*3=6 → max=6  
  p=6*-2=-12 → max=6  
  p=-12*4=-48 → max=6  

- i=1:  
  p=3 → max=6  
  p=3*-2=-6 → max=6  
  p=-6*4=-24 → max=6  

- i=2:  
  p=-2 → max=6  
  p=-2*4=-8 → max=6  

- i=3:  
  p=4 → max=6  

Answer = 6.

## 3. Code
```cpp
int maxProductSubArray(vector<int>& nums) {
    int result = nums[0];
    for(int i=0; i<nums.size()-1; i++) {
        int p = nums[i];
        for(int j=i+1; j<nums.size(); j++) {
            result = max(result, p);
            p *= nums[j];
        }
        result = max(result, p); // include (n-1)th element
    }
    return result;
}
```

## 4. Time & Space Complexity
- **Time Complexity:** O(N²) → double nested loops.  
- **Space Complexity:** O(1).  

---

# Optimal Solution (Prefix & Suffix Products)

## 1. Intuition / Approach
The main difficulty is handling **negative numbers** and **zeros**.  
- A negative number can flip the product.  
- Zeros break continuity of product.  

Key idea:  
- Maintain both **prefix product** (from left to right) and **suffix product** (from right to left).  
- Reset product to 1 when it becomes 0.  
- Take the maximum product encountered during traversal.  

This ensures we capture maximum product subarray even if it lies in the middle and involves negatives.

## 2. Dry Run
Example: `nums = [2, 3, -2, 4]`

- prefix = 1, suffix = 1, ans = -∞  

Traverse:  
- i=0 → prefix=2, suffix=4 → ans=4  
- i=1 → prefix=6, suffix=-8 → ans=6  
- i=2 → prefix=-12, suffix=-2 → ans=6  
- i=3 → prefix=-48, suffix=3 → ans=6  

Final answer = 6.

## 3. Code
```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int prefix = 1, sufix = 1;
        int ans = INT_MIN;
        for(int i=0; i<n; i++) {
            if(prefix == 0) prefix = 1;
            if(sufix == 0) sufix = 1;
            
            prefix *= nums[i];
            sufix *= nums[n - i - 1];
            ans = max(ans, max(prefix, sufix));
        }
        return ans;
    }
};
```

## 4. Time & Space Complexity
- **Time Complexity:** O(N) → single traversal.  
- **Space Complexity:** O(1).  

---
