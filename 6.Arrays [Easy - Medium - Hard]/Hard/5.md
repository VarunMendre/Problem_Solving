# Longest Zero Sum Subarray

## Problem Statement

Given an array of integers, find the length of the longest subarray with sum equal to **0**.

---

## 1. Intuition / Approach (Brute Force)

* Keep track of the cumulative sum at each index.
* Use a hashmap to store the first occurrence of a particular sum.
* If the sum becomes `0` or repeats, we calculate the subarray length.
* The maximum such length is our answer.

## 2. Algorithm (Brute Force)

1. Initialize `sum = 0` and `maxLen = 0`.
2. Traverse the array while maintaining cumulative sum.
3. If `sum == 0`, update `maxLen = i+1`.
4. If the sum already exists in the map, update `maxLen = max(maxLen, i - map[sum])`.
5. Otherwise, store `map[sum] = i`.
6. Return `maxLen`.

## 3. Code (Brute Force)

```cpp
int solve(vector<int>& a) {
    int maxLen = 0;
    unordered_map<int, int> sumIndexMap;
    int sum = 0;

    for (int i = 0; i < a.size(); i++) {
        sum += a[i];

        if (sum == 0) {
            maxLen = i + 1;
        } else if (sumIndexMap.find(sum) != sumIndexMap.end()) {
            maxLen = max(maxLen, i - sumIndexMap[sum]);
        } else {
            sumIndexMap[sum] = i;
        }
    }

    return maxLen;
}
```

## 4. Time & Space Complexity (Brute Force)

* **Time Complexity:** O(n) (single traversal of the array).
* **Space Complexity:** O(n) (for hashmap storage).

---

## 1. Intuition / Approach (Optimal)

* Same idea as brute force, but implemented more cleanly and efficiently.
* Maintain prefix sum and store the first occurrence in hashmap.
* If prefix sum repeats, calculate subarray length.

## 2. Algorithm (Optimal)

1. Initialize `sum = 0` and `maxi = 0`.
2. Traverse the array, update prefix sum.
3. If `sum == 0`, update `maxi = i+1`.
4. If the sum already exists in the map, update `maxi`.
5. Otherwise, store `mpp[sum] = i`.
6. Return `maxi`.

## 3. Code (Optimal)

```cpp
#include <vector>
#include <bits/stdc++.h>
int getLongestZeroSumSubarrayLength(vector<int> &arr) {
    int n = arr.size();

    int sum = 0;
    int maxi = 0;

    unordered_map<int, int> mpp;
    for(int i = 0; i < n; i++) {
        sum += arr[i];

        if(sum == 0) {
            maxi = i + 1;
        }
        else {
            if(mpp.find(sum) != mpp.end()) {
                maxi = max(maxi, i - mpp[sum]);
            }
            else {
                mpp[sum] = i;
            }
        }
    }
    return maxi;
}
```

## 4. Time & Space Complexity (Optimal)

* **Time Complexity:** O(n) (single traversal).
* **Space Complexity:** O(n) (hashmap storage).
