# Subarrays with XOR equal to K

---

## Problem Statement

Given an array of integers `arr` and an integer `k`, find the number of subarrays whose XOR is equal to `k`.

---

## 1. Brute Force Approach

### Intuition / Approach

* Generate all possible subarrays.
* Compute XOR of each subarray.
* If XOR equals `k`, increment the count.

### Algorithm

1. Initialize `cnt = 0`.
2. For every starting index `i`, iterate over ending index `j`.
3. Compute XOR of elements from `i` to `j`.
4. If XOR equals `k`, increment `cnt`.
5. Return `cnt`.

### Code

```cpp
#include <bits/stdc++.h>

int subarraysXor(vector<int> &arr, int x)
{
    int n = arr.size();
    int cnt = 0;
    for(int i = 0; i < n; i++) {
        for(int j = i; j < n; j++) {
            int xorr = 0;

            for(int k = i; k <= j; k++) {
                xorr ^= arr[k];
            }
            if(xorr == x) cnt++;
        }
    }

    return cnt;
}
```

### Time & Space Complexity

* **Time Complexity:** O(N³)
* **Space Complexity:** O(1)

---

## 2. Better Approach

### Intuition / Approach

* Instead of recomputing XOR for every subarray, maintain cumulative XOR while expanding the subarray.

### Algorithm

1. Initialize `cnt = 0`.
2. For every starting index `i`, set `xorr = 0`.
3. For every ending index `j`, update `xorr ^= arr[j]`.
4. If `xorr == k`, increment `cnt`.
5. Return `cnt`.

### Code

```cpp
#include <bits/stdc++.h>

int subarraysXor(vector<int> &arr, int x)
{
    int n = arr.size();
    int cnt = 0;
    for(int i = 0; i < n; i++) {
        int xorr = 0;
        for(int j = i; j < n; j++) {
            xorr ^= arr[j];
            if(xorr == x) cnt++;
        }
    }

    return cnt;
}
```

### Time & Space Complexity

* **Time Complexity:** O(N²)
* **Space Complexity:** O(1)

---

## 3. Optimal Approach

### Intuition / Approach

* Use prefix XOR and a hashmap to count the required subarrays.
* If `xr` is the prefix XOR till index `i` and we want subarray XOR = `k`, then check if `(xr ^ k)` has appeared before.

### Algorithm

1. Initialize `cnt = 0` and `xr = 0`.
2. Create a hashmap `mpp` to store prefix XOR frequencies.
3. Iterate over array:

   * Update `xr ^= arr[i]`.
   * Compute `x = xr ^ k`.
   * If `x` exists in `mpp`, increment `cnt` by its frequency.
   * Update `mpp[xr]`.
4. Return `cnt`.

### Code

```cpp
#include <bits/stdc++.h>

int subarraysXor(vector<int> &arr, int k)
{
    int n = arr.size();
    int xr = 0;
    map<int, int> mpp;

    mpp[xr]++; // {0, 1}
    int cnt = 0;
    for(int i = 0; i < n; i++) {
        xr ^= arr[i];

        int x = xr ^ k; // check for required value
        cnt += mpp[x];

        mpp[xr]++;
    }
    return cnt;
}
```

### Time & Space Complexity

* **Time Complexity:** O(N) with `unordered_map`, O(N log N) with `map`
* **Space Complexity:** O(N) (in worst case if all elements are unique)
