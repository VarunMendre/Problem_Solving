# Majority Element II - Problem Explanation and Solutions

## 1. Brute Force Approach

### Problem Statement
Given an integer array `nums` of size `n`, find all elements that appear more than `⌊n / 3⌋` times.

### Algorithm / Approach
- Iterate through each element.
- For each element, count its occurrences by looping through the array again.
- If count > n/3 and not already in answer, add it to the result vector.

### Intuition / Dry Run
We check every element against every other to count occurrences. If an element’s count is greater than n/3, it's added to the result.  
Example: nums = [3,2,3] → element 3 count is 2 (> 1) → add 3.

### Code
```cpp
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;
        for(int i = 0; i < n; i++) {
            int cnt = 0;
            for(int j = 0; j < n; j++) {
                if(nums[i] == nums[j]) {
                    cnt++;
                }
            }
            if(cnt > n/3) {
                if(find(ans.begin(), ans.end(), nums[i]) == ans.end()) {
                    ans.push_back(nums[i]);
                }
            }
        }
        return ans;
    }
};
```

### Time & Space Complexity
- Time Complexity: **O(n²)** (Nested loops)
- Space Complexity: **O(1)** (Ignoring output storage)


---

## 2. Better Approach (Using Hash Map)

### Problem Statement
Same as above.

### Algorithm / Approach
- Use a map to store frequency of each element.
- Iterate through the array and update frequency in the map.
- If any element’s frequency equals `⌊n/3⌋ + 1`, add it to the result.
- Stop early if two majority elements are found.

### Intuition / Dry Run
Instead of counting for every element, we maintain a running count in a map.  
Example: nums = [1,1,1,3,3,2,2,2] → frequency counts help detect elements > n/3 faster.

### Code
```cpp
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        map<int, int> mpp;
        int majorityCnt = (int)(n / 3) + 1;

        for(int i = 0; i < n; i++) {
            mpp[nums[i]]++;
            if(mpp[nums[i]] == majorityCnt) {
                ans.push_back(nums[i]);
            }
            if(ans.size() == 2) break;
        }
        return ans;
    }
};
```

### Time & Space Complexity
- Time Complexity: **O(n log n)** (Map operations)
- Space Complexity: **O(n)** (Map storage)


---

## 3. Optimal Approach (Moore's Voting Algorithm)

### Problem Statement
Same as above.

### Algorithm / Approach
- There can be at most 2 elements that appear more than n/3 times.
- Maintain two candidate variables (`ele1`, `ele2`) and their counts.
- First pass: Find potential candidates using Boyer-Moore voting.
- Second pass: Verify counts of the candidates.

### Intuition / Dry Run
We reduce the problem to at most two possible majority elements using counters and then verify them.  
Example: nums = [1,1,1,3,3,2,2,2] → candidates become 1 and 2, verified counts confirm they are majorities.

### Code
```cpp
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        int n = nums.size();
        int ele1 = INT_MIN, ele2 = INT_MIN;
        int cnt1 = 0, cnt2 = 0;

        for(int i = 0; i < n; i++) {
            if(cnt1 == 0 && nums[i] != ele2) {
                cnt1 = 1;
                ele1 = nums[i];
            }
            else if(cnt2 == 0 && nums[i] != ele1) {
                cnt2 = 1;
                ele2 = nums[i];
            }
            else if(nums[i] == ele1) cnt1++;
            else if(nums[i] == ele2) cnt2++;
            else {
                cnt1--; cnt2--;
            }
        }

        vector<int> ans;
        cnt1 = 0, cnt2 = 0;
        int miniMojority = (int)(n/3) + 1;
        for(int i = 0; i < n; i++) {
            if(ele1 == nums[i]) cnt1++;
            if(ele2 == nums[i]) cnt2++;
        }

        if(cnt1 >= miniMojority) ans.push_back(ele1);
        if(cnt2 >= miniMojority) ans.push_back(ele2);

        return ans;
    }
};
```

### Time & Space Complexity
- Time Complexity: **O(n)** (Two passes)
- Space Complexity: **O(1)** (Constant extra space)
