# Merge Intervals

---

## Problem Statement

Given a collection of intervals, merge all overlapping intervals and return an array of the non-overlapping intervals that cover all the intervals in the input.

---

## 1. Brute Force Approach

### Intuition / Approach

* Sort the intervals by their start time.
* For each interval, try to merge it with all subsequent overlapping intervals.
* Skip intervals already covered in the merged range.

### Algorithm

1. Sort all intervals by starting time.
2. Iterate through intervals:

   * For each interval, set `start` and `end`.
   * If `end` is already covered in `ans`, skip it.
   * Otherwise, extend `end` by checking all overlapping intervals.
   * Push merged interval into `ans`.
3. Return `ans`.

### Code

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        int n = intervals.size();
        sort(intervals.begin(), intervals.end());
        vector<vector<int>> ans;

        for(int i=0;i<n;i++) {
            int start = intervals[i][0];
            int end = intervals[i][1];

            if(!ans.empty() && end <= ans.back()[1]) continue;

            for(int j=i+1;j<n;j++) {
                if(intervals[j][0] <= end) {
                    end = max(end, intervals[j][1]);
                }
                else {
                    break;
                }
            }
            ans.push_back({start, end});
        }

        return ans;
    }
};
```

### Time & Space Complexity

* **Time Complexity:** O(N log N) for sorting + O(NÂ²) for merging.
* **Space Complexity:** O(N).

---

## 2. Optimal Approach

### Intuition / Approach

* Sort the intervals by start time.
* Iterate once and merge intervals on the go.
* If the current interval overlaps with the last one in `ans`, merge them.
* Otherwise, push it as a new interval.

### Algorithm

1. Sort all intervals by starting time.
2. Initialize an empty result vector `ans`.
3. Traverse all intervals:

   * If `ans` is empty or the current interval does not overlap with `ans.back()`, add it directly.
   * Otherwise, merge by updating `ans.back()[1]`.
4. Return `ans`.

### Code

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        int n = intervals.size();
        sort(intervals.begin(), intervals.end());
        
        vector<vector<int>> ans;

        for(int i=0;i<n;i++) {
            if(ans.empty() || intervals[i][0] > ans.back()[1]) {
                ans.push_back(intervals[i]);
            }
            else {
                ans.back()[1] = max(ans.back()[1], intervals[i][1]);
            }
        }

        return ans;
    }
};
```

### Time & Space Complexity

* **Time Complexity:** O(N log N) for sorting + O(N) for merging.
* **Space Complexity:** O(N).
