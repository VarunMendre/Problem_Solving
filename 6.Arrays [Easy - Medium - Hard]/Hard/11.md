# Reverse Pairs Problem

## Problem Statement
You are given an integer array `nums`. A reverse pair is a pair `(i, j)` where:
- `0 <= i < j < nums.length`
- `nums[i] > 2 * nums[j]`

Return the number of reverse pairs in the array.

---

# Brute Force Solution

## 1. Intuition / Approach
The brute force method directly checks every possible pair `(i, j)` with `i < j`.  
For each pair, it verifies whether `nums[i] > 2 * nums[j]`.  
If the condition is satisfied, we increment the counter.  
This method is straightforward but inefficient for large arrays because it involves nested loops.

## 2. Dry Run
Example: `nums = [2, 4, 3, 5, 1]`

- i=0 (2):  
  - j=1 → 2 > 8? (No)  
  - j=2 → 2 > 6? (No)  
  - j=3 → 2 > 10? (No)  
  - j=4 → 2 > 2? (No)

- i=1 (4):  
  - j=2 → 4 > 6? (No)  
  - j=3 → 4 > 10? (No)  
  - j=4 → 4 > 2? (Yes) → count = 1

- i=2 (3):  
  - j=3 → 3 > 10? (No)  
  - j=4 → 3 > 2? (Yes) → count = 2

- i=3 (5):  
  - j=4 → 5 > 2? (Yes) → count = 3

Final count = 3.

## 3. Code
```cpp
class Solution {
public:
    int reversePairs(vector<int>& nums) {
        int cnt = 0;
        int n = nums.size();
        for(int i=0; i<n; i++) {
            for(int j=i+1; j<n; j++) {
                if(nums[i] > (2LL * nums[j])) cnt++;
            }
        }
        return cnt;
    }
};
```

## 4. Time & Space Complexity
- **Time Complexity:** O(N²) → Two nested loops over array of size `n`.  
- **Space Complexity:** O(1) → No extra data structures used.  

---

# Optimal Solution (Using Modified Merge Sort)

## 1. Intuition / Approach
The brute force solution is too slow for large inputs.  
To optimize, we use a **divide-and-conquer** strategy similar to **merge sort**.  
Key idea:  
- While merging two sorted halves, we can efficiently count how many elements in the right half satisfy `arr[i] > 2*arr[j]`.  
- Then we merge the two halves like normal merge sort.  

This reduces the time complexity significantly.

## 2. Dry Run
Example: `nums = [2, 4, 3, 5, 1]`

1. Divide array into halves recursively.  
   Left = [2,4,3], Right = [5,1]  
2. Solve for each half, then merge.  
3. While merging [2,4,3] and [5,1]:  
   - Count pairs where left element > 2 * right element.  
   - Example: (4,1), (3,1), (5,1) … etc.  
   - During merge, elements are placed in sorted order to ensure future counts are efficient.  

Final count after complete merging = 3.

## 3. Code
```cpp
class Solution {
private:
    void merge(vector<int> &arr, int low, int mid, int high) {
        vector<int> temp;
        int left = low, right = mid + 1;

        while (left <= mid && right <= high) {
            if (arr[left] <= arr[right]) {
                temp.push_back(arr[left++]);
            } else {
                temp.push_back(arr[right++]);
            }
        }
        while (left <= mid) temp.push_back(arr[left++]);
        while (right <= high) temp.push_back(arr[right++]);

        for (int i = low; i <= high; i++) arr[i] = temp[i - low];
    }

    int countPairs(vector<int> &arr, int low, int mid, int high) {
        int right = mid + 1, cnt = 0;
        for (int i = low; i <= mid; i++) {
            while (right <= high && (long long)arr[i] > 2LL * arr[right]) right++;
            cnt += (right - (mid + 1));
        }
        return cnt;
    }

    int mergeSort(vector<int> &arr, int low, int high) {
        if (low >= high) return 0;
        int mid = (low + high) / 2;
        int cnt = mergeSort(arr, low, mid);
        cnt += mergeSort(arr, mid + 1, high);
        cnt += countPairs(arr, low, mid, high);
        merge(arr, low, mid, high);
        return cnt;
    }

public:
    int reversePairs(vector<int>& nums) {
        return mergeSort(nums, 0, nums.size() - 1);
    }
};
```

## 4. Time & Space Complexity
- **Time Complexity:** O(N log N)  
  - Merge sort divides the array in log N levels.  
  - Counting pairs + merging takes O(N) at each level.  
  - Hence, total = O(N log N).  

- **Space Complexity:** O(N)  
  - Due to temporary array used in merge function.  

---
