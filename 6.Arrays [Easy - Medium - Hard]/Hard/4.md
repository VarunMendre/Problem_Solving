# 4-Sum Problem

## Problem Statement

Given an array of integers `nums` and an integer `target`, return all
unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that: -
`a, b, c, d` are distinct indices. -
`nums[a] + nums[b] + nums[c] + nums[d] == target`.

You must not return duplicate quadruplets. The solution can be in any
order.

------------------------------------------------------------------------

## Brute Force Approach

### 1. Intuition

The simplest way is to check **all possible quadruplets** of elements
and see if their sum equals the target.\
This guarantees correctness but is highly inefficient.

### 2. Approach / Algorithm

1.  Use 4 nested loops (`i, j, k, l`) to generate every possible
    quadruplet.
2.  Calculate their sum.
3.  If sum equals target:
    -   Sort the quadruplet to avoid duplicates in different orders.
    -   Insert into a `set` for uniqueness.
4.  Convert the set to a vector and return.

### 3. Dry Run

Input: `nums = [1,0,-1,0,-2,2], target = 0`

-   Pick indices `(0,1,2,3)` → `[1,0,-1,0]` → sum `0` → valid.
-   Pick indices `(0,1,2,4)` → `[1,0,-1,-2]` → sum `-2` → not valid.
-   Continue checking all combinations.

Unique valid quadruplets found: `[[-2,-1,1,2], [-2,0,0,2], [-1,0,0,1]]`

### 4. Code

``` cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        int n = nums.size();
        set<vector<int>> st;

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    for (int l = k + 1; l < n; l++) {
                        long long sum = nums[i] + nums[j];
                        sum += nums[k];
                        sum += nums[l];
                        if (sum == target) {
                            vector<int> temp = {nums[i], nums[j], nums[k], nums[l]};
                            sort(temp.begin(), temp.end());
                            st.insert(temp);
                        }
                    }
                }
            }
        }

        return vector<vector<int>>(st.begin(), st.end());
    }
};
```

### 5. Time & Space Complexity

-   **Time:** O(n\^4 \* log M)\
    n\^4 quadruplet generation.\
    log M for set insertion.

-   **Space:** O(M \* 4) for storing unique quadruplets.

------------------------------------------------------------------------

## Better Approach (Using Hashing)

### 1. Intuition

Instead of 4 loops, fix 2 numbers (i, j) and then find the other 2
numbers using hashing.\
This reduces 1 loop and makes it more efficient.

### 2. Approach / Algorithm

1.  Iterate with i and j for the first two numbers.\
2.  Use a hash set to store elements seen so far for the third index k.\
3.  Compute the fourth element as:\
    `fourth = target - (nums[i] + nums[j] + nums[k])`\
4.  If fourth is already in the hash set, then a quadruplet is found.\
5.  Insert sorted quadruplet into a set to avoid duplicates.

### 3. Dry Run

Input: nums = \[1,0,-1,0,-2,2\], target = 0

-   Fix (i=0, j=1) → \[1,0\]\
-   Loop k=2 → nums\[k\]=-1\
    Fourth = 0 - (1+0+(-1)) = 0 → not in set yet. Insert -1.\
-   Loop k=3 → nums\[k\]=0\
    Fourth = 0 - (1+0+0) = -1 → found in set.\
    Quadruplet \[1,0,0,-1\] → sorted → \[-1,0,0,1\].

### 4. Code

``` cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        int n = nums.size();
        set<vector<int>> st;

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                set<long long> hashSet;
                for (int k = j + 1; k < n; k++) {
                    long long sum = nums[i] + nums[j] + nums[k];
                    long long fourth = target - sum;

                    if (hashSet.find(fourth) != hashSet.end()) {
                        vector<int> temp = {nums[i], nums[j], nums[k], (int)fourth};
                        sort(temp.begin(), temp.end());
                        st.insert(temp);
                    }

                    hashSet.insert(nums[k]);
                }
            }
        }

        return vector<vector<int>>(st.begin(), st.end());
    }
};
```

### 5. Time & Space Complexity

-   **Time:** O(n\^3 \* log M)\
    3 nested loops → n\^3\
    log factor for set insertion.

-   **Space:** O(n + M)\
    Hash set for elements (O(n) per iteration).\
    Set for unique quadruplets (O(M)).

------------------------------------------------------------------------

## Optimal Approach (Two Pointers)

### 1. Intuition

By sorting the array, we can avoid duplicates easily and use the
two-pointer technique (like 2-sum).\
This reduces complexity further.

### 2. Approach / Algorithm

1.  Sort the array.\
2.  Fix two numbers with indices i and j.\
3.  Use two pointers k (left) and l (right) to find remaining two
    numbers.
    -   If sum \< target → move k++.\
    -   If sum \> target → move l--.\
    -   If sum == target → store quadruplet.\
4.  Skip duplicates for i, j, k, l.

### 3. Dry Run

Input: nums = \[1,0,-1,0,-2,2\], target = 0\
Sorted: \[-2,-1,0,0,1,2\]

-   i=0 (-2), j=1 (-1), k=2 (0), l=5 (2)\
    Sum = -1 → move k.\
-   k=3 (0), l=5 (2) → Sum = -1 → move k.\
-   k=4 (1), l=5 (2) → Sum = 0 → store \[-2,-1,1,2\].

Continue for all pairs...

Result:\
`[[-2,-1,1,2], [-2,0,0,2], [-1,0,0,1]]`

### 4. Code

``` cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        int n = nums.size();
        vector<vector<int>> ans;
        sort(nums.begin(), nums.end());

        for (int i = 0; i < n; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            for (int j = i + 1; j < n; j++) {
                if (j != i + 1 && nums[j] == nums[j - 1]) continue;

                int k = j + 1;
                int l = n - 1;

                while (k < l) {
                    long long sum = nums[i];
                    sum += nums[j];
                    sum += nums[k];
                    sum += nums[l];

                    if (sum < target) k++;
                    else if (sum > target) l--;
                    else {
                        ans.push_back({nums[i], nums[j], nums[k], nums[l]});
                        k++, l--;
                        while (k < l && nums[k] == nums[k - 1]) k++;
                        while (k < l && nums[l] == nums[l + 1]) l--;
                    }
                }
            }
        }
        return ans;
    }
};
```

### 5. Time & Space Complexity

-   **Time:** O(n\^3)\
    Outer two loops O(n\^2)\
    Two-pointer scan O(n)\
    Total O(n\^3).

-   **Space:** O(1) (ignoring output).

------------------------------------------------------------------------

## Summary

  ----------------------------------------------------------------------------
  Approach      Time Complexity         Space Complexity         Notes
  ------------- ----------------------- ------------------------ -------------
  Brute         O(n\^4)                 O(M)                     Check all
                                                                 quadruplets

  Better        O(n\^3)                 O(n + M)                 Hashing
                                                                 improves
                                                                 efficiency

  Optimal       O(n\^3)                 O(1)                     Sorting + two
                                                                 pointers
  ----------------------------------------------------------------------------
