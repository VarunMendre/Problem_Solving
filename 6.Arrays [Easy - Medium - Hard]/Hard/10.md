# Count Inversions in an Array

## Problem Statement

For a given integer array/list `ARR` of size `N` containing all distinct
values, find the total number of **Inversions** that may exist.

An inversion is defined for a pair of integers in the array/list when
the following two conditions are met:

1.  `ARR[i] > ARR[j]`
2.  `i < j`

Where `i` and `j` denote the indices ranging from `[0, N)`.

------------------------------------------------------------------------

## 1. Intuition / Approach

The naive approach would be to use two nested loops and check all
possible pairs `(i, j)` to see if they satisfy the inversion conditions.
However, this would take `O(N^2)` time, which is inefficient for large
arrays.

To optimize, we can leverage **Merge Sort**.\
- While merging two sorted halves, if an element from the left half is
greater than an element from the right half, then all the remaining
elements in the left half (because the left half is sorted) will also
form inversions with that element.\
- Thus, while performing the merge step, we can count the number of such
inversions efficiently.

This reduces the time complexity from `O(N^2)` to `O(N log N)`.

------------------------------------------------------------------------

## 2. Dry Run

Let `ARR = [5, 3, 2, 1, 4]`

-   Split into halves → `[5, 3, 2]` and `[1, 4]`
-   Further split `[5, 3, 2]` → `[5, 3]` and `[2]`\
-   Count inversions while merging:
    -   Merging `[5]` and `[3]` → inversion: `(5, 3)` → count = 1\
    -   Merging `[3, 5]` with `[2]` → inversions: `(3, 2), (5, 2)` →
        count = 2\
        Total so far = 3
-   Now merge `[1, 4]` → no inversions (already sorted).\
-   Finally merge `[2, 3, 5]` and `[1, 4]`:
    -   `(2, 1), (3, 1), (5, 1)` → 3 inversions\
    -   `(5, 4)` → 1 inversion\
        Total = 4

**Final Answer = 3 + 0 + 4 = 7 inversions**.

------------------------------------------------------------------------

## 3. Code (Optimal Solution)

``` cpp
#include <bits/stdc++.h>
using namespace std;

long long merge(vector<long long> &arr , int low , int mid , int high){
    vector<long long> temp;
    int left = low;
    int right = mid + 1;
    long long cnt = 0;

    while(left <= mid && right <= high){
        if(arr[left] <= arr[right]){
            temp.push_back(arr[left++]);
        }
        else{
            temp.push_back(arr[right++]);
            cnt += (mid - left + 1);
        }
    }

    while(left <= mid) temp.push_back(arr[left++]);
    while(right <= high) temp.push_back(arr[right++]);

    for(int i = low; i <= high; i++){
        arr[i] = temp[i - low];
    }
    return cnt;
}

long long ms(vector<long long> &arr, int low, int high){ 
    long long cnt = 0;
    if(low >= high) return cnt; 

    int mid = (low + high) / 2;
    cnt += ms(arr, low, mid);
    cnt += ms(arr, mid + 1, high);
    cnt += merge(arr, low, mid, high);
    return cnt;
}

long long getInversions(long long *arr, int n){
    vector<long long> v(arr, arr+n);
    return ms(v, 0, n - 1);
}
```

------------------------------------------------------------------------

## 4. Time & Space Complexity

-   **Time Complexity:** `O(N log N)`\
    Explanation: Merge Sort divides the array recursively (`O(log N)`)
    and merging takes linear time `O(N)`. Hence, total = `O(N log N)`.

-   **Space Complexity:** `O(N)`\
    Explanation: Extra space is required for the temporary array during
    the merge process.

------------------------------------------------------------------------
