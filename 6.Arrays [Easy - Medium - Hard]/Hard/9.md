
# Missing and Repeating Numbers

---

## Brute Force Approach

### Problem Statement
Given an array of size `n` containing numbers from `1` to `n`, one number is missing and one number is repeating. Find both numbers.

### 1. Intuition
The brute force idea is simple: for each number from `1` to `n`, count its frequency in the array.  
- If the frequency is `0`, it is the missing number.  
- If the frequency is `2`, it is the repeating number.

### 2. Approach / Dry Run
- Iterate through numbers `1` to `n`.  
- For each number, traverse the array and count occurrences.  
- Identify the repeating and missing numbers.  

**Example:**  
Array = `[3,1,2,5,3]`  
- For `1`: count = 1 ✅  
- For `2`: count = 1 ✅  
- For `3`: count = 2 → repeating = 3  
- For `4`: count = 0 → missing = 4  
- Output = `{3,4}`

### 3. Code
```cpp
vector<int> findMissingRepeatingNumbers(vector < int > arr) {
    int n = arr.size();
    
    int missing = -1, repeating = -1;
    for(int i = 1; i <= n; i++ ) {
        int cnt = 0;

        for(int j = 0; j < n; j++) {
            if(arr[j] == i) {
                cnt++;
            }
        }    
        if(cnt == 2) {
            repeating = i;
        }
        else if(cnt == 0) {
           missing = i;
        }
        if(missing != -1 && repeating != -1) {
            break;
        }
    }   
    return {repeating, missing};
}
```

### 4. Time & Space Complexity
- **Time Complexity:** O(N²) (for each element, traverse entire array).  
- **Space Complexity:** O(1).  

---

## Better Approach (Hashing)

### Problem Statement
Same as above.

### 1. Intuition
Instead of repeatedly counting, we can use a hash array to store the frequency of each element in a single traversal.

### 2. Approach / Dry Run
- Initialize a frequency array of size `n+1` with all zeros.  
- Traverse the array and update counts.  
- Traverse the hash array to find which element has frequency `0` (missing) and `2` (repeating).  

**Example:**  
Array = `[3,1,2,5,3]`  
Hash = `[0,1,1,2,0,1]`  
- Index `3` has freq = 2 → repeating = 3  
- Index `4` has freq = 0 → missing = 4  
- Output = `{3,4}`  

### 3. Code
```cpp
vector<int> findMissingRepeatingNumbers(vector < int > a) {
    int n = a.size(); 
    int hashArr[n + 1] = {0};

    for(int i = 0; i < n; i++) {
        hashArr[a[i]]++;
    }

    int missing = -1,repeating = -1;
    for(int i = 1; i <= n; i++) {
        if(hashArr[i] == 2) repeating = i;
        else if(hashArr[i] == 0) missing = i;
        
        if(missing != -1 && repeating != -1) 
            break;
    }
    return {repeating, missing};
}
```

### 4. Time & Space Complexity
- **Time Complexity:** O(2N) ≈ O(N).  
- **Space Complexity:** O(N) (hash array).  

---

## Optimal Approach (Mathematical)

### Problem Statement
Same as above.

### 1. Intuition
We can solve using mathematical formulas of sum and sum of squares.  
Let:  
- `X` = repeating number  
- `Y` = missing number  
- `S` = sum of array, `SN` = expected sum  
- `S2` = sum of squares of array, `S2N` = expected sum of squares  

Then:  
- `S - SN = X - Y`  
- `S2 - S2N = X² - Y² = (X-Y)(X+Y)`  
From this we can solve for `X` and `Y`.  

### 2. Approach / Dry Run
**Example:**  
Array = `[3,1,2,5,3]`  
- `SN = 15`, `S2N = 55`  
- `S = 14`, `S2 = 48`  
- `val1 = S - SN = -1 = X - Y`  
- `val2 = (S2 - S2N)/val1 = (48-55)/(-1) = 7 = X + Y`  
- `X = (val1 + val2)/2 = (6)/2 = 3`  
- `Y = X - val1 = 3 - (-1) = 4`  
- Output = `{3,4}`  

### 3. Code
```cpp
vector<int> findMissingRepeatingNumbers(vector < int > a) {
    long long n = a.size(); // size of the array

    // Find Sn and S2n:
    long long SN = (n * (n + 1)) / 2;
    long long S2N = (n * (n + 1) * (2 * n + 1)) / 6;

    // Calculate S and S2:
    long long S = 0, S2 = 0;
    for (int i = 0; i < n; i++) {
        S += a[i];
        S2 += (long long)a[i] * (long long)a[i];
    }

    //S-Sn = X-Y:
    long long val1 = S - SN;

    // S2-S2n = X^2-Y^2:
    long long val2 = S2 - S2N;

    //Find X+Y = (X^2-Y^2)/(X-Y):
    val2 = val2 / val1;

    //Find X and Y: 
    long long x = (val1 + val2) / 2;
    long long y = x - val1;

    return {(int)x, (int)y};
}
```

### 4. Time & Space Complexity
- **Time Complexity:** O(N).  
- **Space Complexity:** O(1).  
