# ğŸ”¹ Linked List Problem 4

---

## ğŸ§© Problem 1: Odd & Even Linked List

### ğŸ“˜ Problem Description:
Rearrange a given linked list such that all nodes positioned at **odd indices** come before those at **even indices** while maintaining their relative order.

Example:
```
Input:  1 -> 2 -> 3 -> 4 -> 5
Output: 1 -> 3 -> 5 -> 2 -> 4
```

---

### ğŸªœ i. Naive Approach

```cpp
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        vector<int> arr;
        ListNode* temp = head;

        while (temp != NULL && temp->next != NULL) {
            arr.push_back(temp->val);
            temp = temp->next->next;
        }
        if (temp) arr.push_back(temp->val);

        temp = head->next;
        while (temp != NULL && temp->next != NULL) {
            arr.push_back(temp->val);
            temp = temp->next->next;
        }
        if (temp) arr.push_back(temp->val);

        int i = 0;
        temp = head;
        while (temp != NULL) {
            temp->val = arr[i];
            i++;
            temp = temp->next;
        }

        return head;
    }
};
```

### ğŸ“Š Complexity Analysis:
- **Time Complexity:** O(2N) â†’ traverses the list twice.  
- **Space Complexity:** O(N) â†’ uses extra array to store reordered values.

### ğŸ’¡ Explanation:
The algorithm first collects all **odd-positioned elements** into an array, then all **even-positioned elements**, and finally rewrites the linked list using those stored values. While straightforward, this approach uses extra space and isnâ€™t in-place.

---

### âš¡ ii. Optimal Approach (In-Place Reordering)

```cpp
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if (head == NULL || head->next == NULL) return head;

        ListNode* odd = head;
        ListNode* even = head->next;
        ListNode* evenHead = head->next;

        while (even != NULL && even->next != NULL) {
            odd->next = odd->next->next;
            even->next = even->next->next;

            odd = odd->next;
            even = even->next;
        }

        odd->next = evenHead;
        return head;
    }
};
```

### ğŸ“Š Complexity Analysis:
- **Time Complexity:** O(N)  
- **Space Complexity:** O(1)

### ğŸ’¡ Explanation:
- Maintain **two separate pointers**: one for odd nodes and one for even nodes.
- Rearrange their `next` pointers to link all odds first, followed by evens.
- The algorithm works **in-place** â€” no extra data structures used.

---

## ğŸ§© Problem 2: Delete Nth Node from End

### ğŸ“˜ Problem Description:
Given the head of a linked list, delete the **Nth node from the end** of the list and return its head.

Example:
```
Input:  head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
```

---

### âš¡ Optimal Approach: Two-Pointer Technique

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* fast = head;

        for (int i = 0; i < n; i++) {
            fast = fast->next;
        }

        if (fast == NULL) {
            ListNode* newHead = head->next;
            delete head;
            return newHead;
        }

        ListNode* slow = head;
        while (fast->next != NULL) {
            fast = fast->next;
            slow = slow->next;
        }

        ListNode* deleteNode = slow->next;
        slow->next = slow->next->next;
        delete deleteNode;

        return head;
    }
};
```

### ğŸ“Š Complexity Analysis:
- **Time Complexity:** O(N) â€” single traversal of the list.  
- **Space Complexity:** O(1) â€” constant space.

### ğŸ’¡ Explanation:
1. Use two pointers â€” **fast** and **slow**.
2. Move `fast` pointer `n` steps ahead.
3. Then move both pointers together until `fast` reaches the end.
4. The `slow` pointer will point to the node just before the one to delete.
5. Update pointers and free the target node.

---

### ğŸ§  Key Takeaways:
- Use **two-pointer technique** for problems involving relative positions (like deleting Nth node from end).
- **Odd-Even Linked List** can be done **in O(1) space** with pointer manipulation.
- Always consider **edge cases** (empty list, single node, N = length of list).

---

**ğŸ“‚ File:** `4.md`  
**ğŸ§‘â€ğŸ’» Author:** Varun Mendre  
**ğŸ“š Topic:** Linked List (Medium Level)
