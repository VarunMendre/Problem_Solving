# Linked List – Detailed Explanation (with C++ Implementation)

---

## 1. What is Linked List?

A **Linked List** is a linear data structure where elements (called *nodes*) are connected using pointers.  
Each node contains two parts:
- **Data** – stores the value.
- **Pointer (next)** – stores the address of the next node.

Unlike arrays, linked lists are **not stored in contiguous memory locations**, allowing **dynamic memory allocation** and **efficient insertions/deletions**.

### Example Representation:
```
[10 | *] -> [20 | *] -> [30 | NULL]
```

---

## 2. Where is it used?

Linked Lists are used in:
- Implementing stacks, queues, and graphs.
- Undo/Redo operations in editors.
- Dynamic memory management.
- Real-time systems requiring frequent insertion/deletion.

---

## 3. Struct/Class in C++ and Java

### C++ Implementation:
```cpp
class Node {
public:
    int data;
    Node* next;

    Node(int data1, Node* next1 = nullptr) {
        data = data1;
        next = next1;
    }
};
```

### Java Equivalent:
```java
class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        this.next = null;
    }
}
```

---

## 4. Memory Space Used

Each node in a linked list takes:
- **Data space** (for the actual value)
- **Pointer space** (to store the address of the next node)

For example, in a 64-bit system:  
If `int` = 4 bytes and pointer = 8 bytes → each node = 12 bytes.

---

## 5. Difference between `Node` and `Node*`

| Term | Description |
|------|--------------|
| `Node` | Represents the structure (blueprint) of a node. |
| `Node*` | Pointer that stores the address of a Node. Used to link nodes together. |

Example:
```cpp
Node n1(10);
Node* head = &n1; // head points to n1
```

---

## 6. Array → Linked List Conversion (C++)

```cpp
Node* convertArr2LL(vector<int>& arr) {
    Node* head = new Node(arr[0]);
    Node* mover = head;
    for(int i = 1; i < arr.size(); i++) {
        Node* temp = new Node(arr[i]);
        mover->next = temp;
        mover = temp;
    }
    return head;
}
```

**Explanation:**  
- Start with the first array element as the head node.  
- For each element, create a new node and connect it to the previous one.

---

## 7. Traversal in Linked List

```cpp
void printLL(Node* head) {
    while (head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
}
```

**Time Complexity:** O(n)  
**Space Complexity:** O(1)

---

## 8. Length of a Linked List

```cpp
int length(Node* head) {
    int count = 0;
    while (head != NULL) {
        count++;
        head = head->next;
    }
    return count;
}
```
**Time Complexity:** O(n)

---

## 9. Search an Element in Linked List

```cpp
bool search(Node* head, int key) {
    while (head != NULL) {
        if (head->data == key) return true;
        head = head->next;
    }
    return false;
}
```
**Time Complexity:** O(n)

---

# Insertion & Deletion Operations on Linked List

Below are detailed insertion and deletion operations implemented in C++.

### Full Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

class Node {
public:
    int data;
    Node* next;

    Node(int data1, Node* next1 = nullptr) {
        data = data1;
        next = next1;
    }
};

Node* convertArr2LL(vector<int>&arr) {
    Node* head = new Node(arr[0]);
    Node* mover = head;
    for(int i = 1; i < arr.size(); i++) {
        Node* temp = new Node(arr[i]);
        mover->next = temp;
        mover = temp;
    }
    return head;
}

void printLL(Node* head) {
    while (head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

// Deletion Operations
Node* removeHead(Node* head) {
    if (head == NULL) return head;
    Node* temp = head;
    head = head->next;
    delete temp;
    return head;
}

Node* removeTail(Node* head) {
    if(head == NULL || head->next == NULL) return NULL;
    Node* temp = head;
    while(temp->next->next != NULL) temp = temp->next;
    delete temp->next;
    temp->next = nullptr;
    return head;
}

Node* removeK(Node* head, int k) {
    if(head == NULL) return head;
    if(k == 1) {
        Node* temp = head;
        head = head->next;
        delete temp;
        return head;
    } 
    int cnt = 0;
    Node* temp = head;
    Node* prev = NULL;
    while(temp != NULL) {
        cnt++;
        if(cnt == k) {
            prev->next = prev->next->next;
            delete temp;
            break;
        }
        prev = temp;
        temp = temp->next;
    }
    return head;
}

Node* removeEle(Node* head, int ele) {
    if(head == NULL) return head;
    if(head->data == ele) {
        Node* temp = head;
        head = head->next;
        delete temp;
        return head;
    } 
    Node* temp = head;
    Node* prev = NULL;
    while(temp != NULL) {
        if(temp->data == ele) {
            prev->next = prev->next->next;
            delete temp;
            break;
        }
        prev = temp;
        temp = temp->next;
    }
    return head;
}

// Insertion Operations
Node* insertHead(Node* head, int val) {
    return new Node(val, head);
}

Node* insertTail(Node* head, int val) {
    if(head == NULL) return new Node(val);
    Node* temp = head;
    while(temp->next != NULL) temp = temp->next;
    temp->next = new Node(val);
    return head;
}

Node* insertAtK(Node* head, int val, int k) {
    if(k == 1) return new Node(val, head);
    int cnt = 0;
    Node* temp = head;
    while(temp != NULL) {
        cnt++;
        if(cnt == k - 1) {
            Node* newNode = new Node(val, temp->next);
            temp->next = newNode;
            break;
        }
        temp = temp->next;
    }
    return head;
}

Node* insertBeforeValue(Node* head, int el, int val) {
    if(head == NULL) return NULL;
    if(head->data == val) return new Node(el, head);
    Node* temp = head;
    while(temp->next != NULL) {
        if(temp->next->data == val) {
            Node* newNode = new Node(el, temp->next);
            temp->next = newNode;
            break;
        }
        temp = temp->next;
    }
    return head;
}

int main() {
    vector<int> arr = {10, 20, 30, 40};
    Node* head = convertArr2LL(arr);
    head = insertBeforeValue(head, 100, 50);
    printLL(head);
    return 0;
}
```

---

### ⏱️ **Time and Space Complexity**
| Operation | Time Complexity | Space Complexity |
|------------|-----------------|------------------|
| Insert at Head | O(1) | O(1) |
| Insert at Tail | O(n) | O(1) |
| Insert at Kth Position | O(n) | O(1) |
| Delete Head | O(1) | O(1) |
| Delete Tail | O(n) | O(1) |
| Delete by Value | O(n) | O(1) |
| Traversal | O(n) | O(1) |

---

✅ **Conclusion:**  
Linked Lists are powerful data structures allowing dynamic memory management and fast insertions/deletions, though with higher pointer overhead compared to arrays.
