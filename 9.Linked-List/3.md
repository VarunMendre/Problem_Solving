# 🧩 Problem Solving: Linked List (Part 3)

## 🚀 Problem 1: Length of Loop in a Linked List

### 🔍 Problem Statement
Given a linked list, determine if it contains a loop (cycle).  
If a loop exists, return the **length of the loop**; otherwise, return **0**.

---

## 🧠 Approach 1: Using Hash Map (Brute Force)

### 💡 Intuition
We can use a hash map (`unordered_map<Node*, int>`) to store each node’s address along with a counter (`timer`).  
If we encounter the same node again, it means we’ve detected a loop.  
The **difference** between the current timer and the stored timer gives the **loop length**.

### 🧾 Code
```cpp
int lengthOfLoop(Node *head) {
    unordered_map<Node*, int> mpp;
    Node* temp = head;
    int timer = 1;

    while(temp != NULL) {
        if(mpp.find(temp) != mpp.end()) {
            int loopLength = timer - mpp[temp];
            return loopLength;
        }
        mpp[temp] = timer;
        temp = temp->next;
        timer++;
    }
    return 0;
}
```

### 🧮 Complexity Analysis
- **Time Complexity:** O(N) — Every node is visited once.  
- **Space Complexity:** O(N) — Hash map stores all visited nodes.

---

## ⚡ Approach 2: Floyd’s Cycle Detection Algorithm (Optimal)

### 💡 Intuition
Floyd’s Cycle Detection (Tortoise and Hare) uses two pointers — **slow** and **fast**.  
- Both start at the head.  
- `slow` moves one step at a time, `fast` moves two.  
- If they meet, a loop exists.  
To find the **length**, we move one pointer around the loop until it meets the other again, counting steps.

### 🧾 Code
```cpp
int findLength(Node* slow, Node* fast) {
    int cnt = 1;
    fast = fast->next;
    while(fast != slow) {
        cnt++;
        fast = fast->next;
    }
    return cnt;
}

int lengthOfLoop(Node *head) {
    Node* slow = head;
    Node* fast = head;

    while(fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;

        if(fast == slow) 
            return findLength(slow, fast);
    }
    return 0;
}
```

### 🧮 Complexity Analysis
- **Time Complexity:** O(N) — Traverses list once.  
- **Space Complexity:** O(1) — No extra data structure.

---

## 🧩 Dry Run Example

```
Input:  1 -> 2 -> 3 -> 4 -> 5 -> 3 (loop starts at 3)
```
- Slow and Fast pointers meet at node `4` (inside loop).  
- We move one pointer to count the loop nodes → Output: `3`.

---

## 🚀 Problem 2: Palindrome Linked List

### 🔍 Problem Statement
Check whether a given singly linked list is a palindrome.

---

## 🧠 Approach 1: Using Stack (Naive)

### 💡 Intuition
Push all node values onto a stack.  
Then, traverse again and compare each node value with the top of the stack.

### 🧾 Code
```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        stack<int> st;
        ListNode* temp = head;

        while(temp != NULL) {
            st.push(temp->val);
            temp = temp->next;
        }

        temp = head;
        while(temp != NULL) {
            if(temp->val != st.top()) return false;
            st.pop();
            temp = temp->next;
        }
        return true;
    }
};
```

### 🧮 Complexity Analysis
- **Time Complexity:** O(N)  
- **Space Complexity:** O(N)

---

## ⚡ Approach 2: Reverse Half (Optimal)

### 💡 Intuition
We can optimize space by reversing the **second half** of the linked list and comparing it with the **first half**.  
Once done, restore the list to its original form.

### 🧾 Code
```cpp
class Solution {
private:
    ListNode* reverseLL(ListNode* head) {
        if(head == NULL || head->next == NULL) return head;

        ListNode* newHead = reverseLL(head->next);
        ListNode* front = head->next;
        front->next = head;
        head->next = NULL;
        return newHead;
    }

public:
    bool isPalindrome(ListNode* head) {
        if(head == NULL || head->next == NULL) return true;

        ListNode* slow = head;
        ListNode* fast = head;

        // Find middle node
        while(fast->next != NULL && fast->next->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }

        // Reverse the second half
        ListNode* newHead = reverseLL(slow->next);
        ListNode* first = head;
        ListNode* second = newHead;

        // Compare both halves
        while(second != NULL) {
            if(first->val != second->val) {
                reverseLL(newHead); // Restore
                return false;
            }
            first = first->next;
            second = second->next;
        }

        reverseLL(newHead); // Restore
        return true;
    }
};
```

### 🧮 Complexity Analysis
- **Time Complexity:** O(N)  
- **Space Complexity:** O(1)

---

## 🧩 Dry Run Example

```
Input: 1 -> 2 -> 2 -> 1
```
- Find mid: Node(2)  
- Reverse second half → 1 -> 2  
- Compare → All match → Palindrome ✅

---

## 🏁 Final Notes
- For loop detection, **Floyd’s Algorithm** is the most space-efficient solution.  
- For palindrome checking, **reversing half** is optimal and elegant.  
- Both problems are classic in mastering **Linked List pointers and traversal logic**.
