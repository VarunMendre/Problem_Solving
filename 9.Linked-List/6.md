# 🧮 Linked List Problems — Part 6

## 🧠 Problem 1: Add 1 to a Linked List

### 🔹 Approach 1: Iterative (Using Reversal)

**Idea:**  
Reverse the linked list → Add 1 → Handle carry → Reverse again.

```cpp
Node* reverseLL(Node* node) {
    Node* prev = NULL;
    Node* curr = node;

    while(curr) {
        Node* nextNode = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextNode;
    }
    return prev;
}

Node *addOne(Node *head) {
    head = reverseLL(head);
    Node* temp = head;
    int carry = 1;

    while(temp != NULL) {
        int sum = temp->data + carry;
        temp->data = sum % 10;
        carry = sum / 10;

        if(!temp->next && carry) {
            temp->next = new Node(carry);
            carry = 0;
        }
        temp = temp->next;
    }

    head = reverseLL(head);
    return head;
}
```

✅ **Explanation:**  
- Reverse the LL to make addition easier (like addition from rightmost digit).  
- Traverse and add 1 with carry propagation.  
- If there’s a carry after the last node → add a new node.  
- Finally, reverse back to get the correct order.

📈 **Time Complexity:** O(N)  
💾 **Space Complexity:** O(1)

---

### 🔹 Approach 2: Recursive

**Idea:**  
Use recursion to reach the end and propagate the carry backward.

```cpp
int addHelper(Node* temp) {
    if(temp == NULL) return 1; // Initial carry (1)

    int carry = addHelper(temp->next);
    temp->data += carry;

    if(temp->data < 10) return 0;
    temp->data = 0;
    return 1;
}

Node *addOne(Node *head) {
    int carry = addHelper(head);

    if(carry == 1) {
        Node* newNode = new Node(1);
        newNode->next = head;
        head = newNode;
    }

    return head;
}
```

✅ **Explanation:**  
- Recursive call moves to the end (base case = add 1).  
- As recursion unwinds, propagate carry backward.  
- If the head has a carry → add a new node at the front.

📈 **Time Complexity:** O(N)  
💾 **Space Complexity:** O(N) (recursion stack)

---

## 🧠 Problem 2: Add 2 Numbers Represented by Linked Lists

**Idea:**  
Simulate the addition digit by digit like normal addition.

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummyNode = new ListNode(-1);
        ListNode* curr = dummyNode;

        ListNode* t1 = l1;
        ListNode* t2 = l2;

        int carry = 0;
        while(t1 != NULL || t2 != NULL) {
            int sum = carry;
            if(t1) sum += t1->val;
            if(t2) sum += t2->val;

            ListNode* newNode = new ListNode(sum % 10);
            carry = sum / 10;
            
            curr->next = newNode;
            curr = curr->next;

            if(t1) t1 = t1->next;
            if(t2) t2 = t2->next;
        }

        if(carry) {
            ListNode* newNode = new ListNode(carry);
            curr->next = newNode;
        }

        return dummyNode->next;
    }
};
```

✅ **Explanation:**  
- Traverse both lists simultaneously.  
- Sum digits and manage carry.  
- If one list is shorter, treat missing nodes as 0.  
- Add a final node if carry exists after the last iteration.

📈 **Time Complexity:** O(max(N₁, N₂))  
💾 **Space Complexity:** O(max(N₁, N₂))

---

💡 **Summary:**  
| Problem | Approach | Time Complexity | Space Complexity |
|----------|-----------|----------------|------------------|
| Add 1 to LL | Iterative / Recursive | O(N) | O(1) / O(N) |
| Add 2 Numbers | Iterative | O(max(N₁, N₂)) | O(max(N₁, N₂)) |

---

📘 *This file is part of Varun Mendre’s Problem Solving GitHub Series.*
