# ğŸ§® Linked List Problems â€” Part 6

## ğŸ§  Problem 1: Add 1 to a Linked List

### ğŸ”¹ Approach 1: Iterative (Using Reversal)

**Idea:**  
Reverse the linked list â†’ Add 1 â†’ Handle carry â†’ Reverse again.

```cpp
Node* reverseLL(Node* node) {
    Node* prev = NULL;
    Node* curr = node;

    while(curr) {
        Node* nextNode = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextNode;
    }
    return prev;
}

Node *addOne(Node *head) {
    head = reverseLL(head);
    Node* temp = head;
    int carry = 1;

    while(temp != NULL) {
        int sum = temp->data + carry;
        temp->data = sum % 10;
        carry = sum / 10;

        if(!temp->next && carry) {
            temp->next = new Node(carry);
            carry = 0;
        }
        temp = temp->next;
    }

    head = reverseLL(head);
    return head;
}
```

âœ… **Explanation:**  
- Reverse the LL to make addition easier (like addition from rightmost digit).  
- Traverse and add 1 with carry propagation.  
- If thereâ€™s a carry after the last node â†’ add a new node.  
- Finally, reverse back to get the correct order.

ğŸ“ˆ **Time Complexity:** O(N)  
ğŸ’¾ **Space Complexity:** O(1)

---

### ğŸ”¹ Approach 2: Recursive

**Idea:**  
Use recursion to reach the end and propagate the carry backward.

```cpp
int addHelper(Node* temp) {
    if(temp == NULL) return 1; // Initial carry (1)

    int carry = addHelper(temp->next);
    temp->data += carry;

    if(temp->data < 10) return 0;
    temp->data = 0;
    return 1;
}

Node *addOne(Node *head) {
    int carry = addHelper(head);

    if(carry == 1) {
        Node* newNode = new Node(1);
        newNode->next = head;
        head = newNode;
    }

    return head;
}
```

âœ… **Explanation:**  
- Recursive call moves to the end (base case = add 1).  
- As recursion unwinds, propagate carry backward.  
- If the head has a carry â†’ add a new node at the front.

ğŸ“ˆ **Time Complexity:** O(N)  
ğŸ’¾ **Space Complexity:** O(N) (recursion stack)

---

## ğŸ§  Problem 2: Add 2 Numbers Represented by Linked Lists

**Idea:**  
Simulate the addition digit by digit like normal addition.

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummyNode = new ListNode(-1);
        ListNode* curr = dummyNode;

        ListNode* t1 = l1;
        ListNode* t2 = l2;

        int carry = 0;
        while(t1 != NULL || t2 != NULL) {
            int sum = carry;
            if(t1) sum += t1->val;
            if(t2) sum += t2->val;

            ListNode* newNode = new ListNode(sum % 10);
            carry = sum / 10;
            
            curr->next = newNode;
            curr = curr->next;

            if(t1) t1 = t1->next;
            if(t2) t2 = t2->next;
        }

        if(carry) {
            ListNode* newNode = new ListNode(carry);
            curr->next = newNode;
        }

        return dummyNode->next;
    }
};
```

âœ… **Explanation:**  
- Traverse both lists simultaneously.  
- Sum digits and manage carry.  
- If one list is shorter, treat missing nodes as 0.  
- Add a final node if carry exists after the last iteration.

ğŸ“ˆ **Time Complexity:** O(max(Nâ‚, Nâ‚‚))  
ğŸ’¾ **Space Complexity:** O(max(Nâ‚, Nâ‚‚))

---

ğŸ’¡ **Summary:**  
| Problem | Approach | Time Complexity | Space Complexity |
|----------|-----------|----------------|------------------|
| Add 1 to LL | Iterative / Recursive | O(N) | O(1) / O(N) |
| Add 2 Numbers | Iterative | O(max(Nâ‚, Nâ‚‚)) | O(max(Nâ‚, Nâ‚‚)) |

---

ğŸ“˜ *This file is part of Varun Mendreâ€™s Problem Solving GitHub Series.*
