# 8. Linked List Problems

## Problem 1: Flatten a Multilevel Linked List

### ðŸ§  Intuition
We are given a linked list where each node has two pointers â€” `next` and `child`. Each `child` can lead to another linked list. The task is to flatten this structure into a single sorted list using the `child` pointers.

### ðŸ”¹ Naive Approach
We traverse all nodes using both `next` and `child` pointers, store values in an array, sort them, and rebuild the list.

```cpp
Node* flattenLinkedList(Node* head) {
	vector<int> arr;
	Node* temp = head;

	while (temp != NULL) {
		Node* t1 = temp;
		while (t1 != NULL) {
			arr.push_back(t1->data);
			t1 = t1->child;
		}
		temp = temp->next;
	}

	sort(arr.begin(), arr.end());
	Node* newHead = convertArr2LL(arr);
	return newHead;
}
```

**Time Complexity:** O(N*M log(N*M))  
**Space Complexity:** O(N*M)

### ðŸ”¸ Optimal Approach
We recursively flatten the list and merge two sorted linked lists at a time using the `child` pointer.

```cpp
Node* merge2LL(Node* list1, Node* list2) {
	Node* dummyNode = new Node(-1);
	Node* result = dummyNode;

	while (list1 != NULL && list2 != NULL) {
		if (list1->data < list2->data) {
			result->child = list1;
			result = list1;
			list1 = list1->child;
		} else {
			result->child = list2;
			result = list2;
			list2 = list2->child;
		}
		result->next = nullptr;
	}

	if (list1) result->child = list1;
	else result->child = list2;

	if (dummyNode->child) dummyNode->child->next = nullptr;
	return dummyNode->child;
}

Node* flattenLinkedList(Node* head) {
	if (head == NULL || head->next == NULL) return head;
	Node* mergedHead = flattenLinkedList(head->next);
	head = merge2LL(head, mergedHead);
	return head;
}
```

**Time Complexity:** O(N*M)  
**Space Complexity:** O(1) (ignoring recursion stack)

---

## Problem 2: Copy List with Random Pointer

Each node contains a `val`, a `next` pointer, and a `random` pointer. The goal is to create a **deep copy** of this list.

### ðŸ”¹ Naive Approach (Using HashMap)

We use a map to store the mapping between original and cloned nodes.

```cpp
class Solution {
public:
	Node* copyRandomList(Node* head) {
		Node* temp = head;
		unordered_map<Node*, Node*> mpp;

		while (temp != NULL) {
			Node* newNode = new Node(temp->val);
			mpp[temp] = newNode;
			temp = temp->next;
		}

		temp = head;
		while (temp != NULL) {
			Node* copyNode = mpp[temp];
			copyNode->next = mpp[temp->next];
			copyNode->random = mpp[temp->random];
			temp = temp->next;
		}

		return mpp[head];
	}
};
```

**Time Complexity:** O(2N)  
**Space Complexity:** O(N)

### ðŸ”¸ Optimal Approach (In-place Copy)

We avoid extra space by creating copied nodes in-between original nodes and adjusting pointers smartly.

```cpp
class Solution {
private:
	void insertCopyInBetween(Node* head) {
		Node* temp = head;
		while (temp != NULL) {
			Node* nextElement = temp->next;
			Node* copy = new Node(temp->val);
			copy->next = nextElement;
			temp->next = copy;
			temp = nextElement;
		}
	}

	void connectRandomPointers(Node* head) {
		Node* temp = head;
		while (temp != NULL) {
			Node* copyNode = temp->next;
			copyNode->random = temp->random ? temp->random->next : nullptr;
			temp = temp->next->next;
		}
	}

	Node* deepCopyList(Node* head) {
		Node* temp = head;
		Node* dummyNode = new Node(-1);
		Node* res = dummyNode;

		while (temp != NULL) {
			res->next = temp->next;
			res = res->next;
			temp->next = temp->next->next;
			temp = temp->next;
		}
		return dummyNode->next;
	}

public:
	Node* copyRandomList(Node* head) {
		insertCopyInBetween(head);
		connectRandomPointers(head);
		return deepCopyList(head);
	}
};
```

**Time Complexity:** O(3N)  
**Space Complexity:** O(1) (excluding new list creation)

---

âœ… **Key Takeaways:**
- Use recursion and merging to flatten complex multi-level lists.
- For random pointer problems, in-place manipulation avoids extra space efficiently.