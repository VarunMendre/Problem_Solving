# Linked List Problems ‚Äî Delete Middle Node & Sort Linked List (5.md)

---

## üß© Problem 1: Delete Middle Node of Linked List

### üîç Problem Statement
Given the head of a singly linked list, delete the middle node and return the head of the modified list.  
If the list has only one node, return `NULL` (since removing the only node leaves an empty list).

**Middle definition:** For a list of length `len`, middle is the `len/2`-th node from start when using `0`-based indexing; commonly implemented via `slow-fast` to find node before middle for deletion.

---

### 1. Naive Approach (Two Traversals)

**Idea:** First count the number of nodes, compute the index of the node before the middle, then traverse again to delete the middle node.

**Code:**

```cpp
class Solution {
public:
    ListNode* deleteMiddle(ListNode* head) {
        ListNode* temp = head;
        int cnt = 0;
        while (temp != NULL) {
            cnt++;
            temp = temp->next;
        }

        temp = head;
        int ans = cnt / 2;

        while (temp != NULL) {
            ans--;

            if (ans == 0) {
                ListNode* toBeDeleted = temp->next;

                temp->next = temp->next->next;
                delete toBeDeleted;

                return head;
            }
            temp = temp->next;
        }
        return head;
    }
};
```

**Complexity:**  
- Time: `O(N + N/2)` ‚âà `O(N)` (one pass to count, another to reach deletion point)  
- Space: `O(1)`

**When to use:** Simple to implement, OK when constraints are small. But unnecessary extra traversal can be avoided.

---

### 2. Optimal Approach (Two-Pointer ‚Äî Single Pass)

**Idea:** Use a `slow` pointer to stop at the node *before* middle and `fast` pointer to reach the end faster. By carefully initializing and moving pointers you can delete middle in one traversal (approx. N/2 steps).

**Code:**

```cpp
class Solution {
public:
    ListNode* deleteMiddle(ListNode* head) {
        if(head == NULL || head->next == NULL) return NULL;

        ListNode* slow = head; // will stop one node before middle
        ListNode* fast = head; 

        fast = fast->next->next;

        while(fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }

        ListNode* middleNode = slow->next;
        slow->next = slow->next->next;
        delete middleNode;

        return head;
    }
};
```

**Why it works:**  
- `fast` advances two nodes per iteration; `slow` advances one.  
- By starting `fast` two steps ahead, when `fast` can't continue, `slow->next` will be the middle node (for both even and odd lengths based on the convention used).

**Complexity:**  
- Time: `O(N/2)` ‚âà `O(N)`  
- Space: `O(1)`

**Edge cases:**  
- Empty list or single node ‚Äî handled at start.  
- Even-length lists ‚Äî the algorithm removes the "second" middle? Depends on initialization; given this setup, it targets the floor(len/2) index as intended.

---

## üß© Problem 2: Sort a Linked List in Ascending Order

### üîç Problem Statement
Given the head of a singly linked list, return the list after sorting it in ascending order. Aim for `O(N log N)` time and `O(1)` space (excluding recursion stack).

**Key idea:** Merge Sort works beautifully for linked lists ‚Äî it uses `O(log N)` recursion depth and can merge in-place by re-pointing `next` pointers.

---

### 1. Naive Approach (Array + Sort)

**Idea:** Copy values into an array, sort array, then overwrite linked list node values from sorted array.

**Code:**

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode* temp = head;
        vector<int> arr;

        while(temp != NULL) {
           arr.push_back(temp->val);
           temp = temp->next;
        }
        sort(arr.begin(), arr.end());
        int i =  0;
        temp = head;

        while(temp != NULL) {
            temp->val = arr[i];
            i++;
            temp = temp->next;
        }

        return head;
    }
};
```

**Complexity:**  
- Time: `O(N log N)` for sorting + `O(N)` copying = `O(N log N)`  
- Space: `O(N)` for the array

**When to use:** Fast to code; acceptable when extra memory is allowed. Not ideal for in-place constraints.

---

### 2. Optimal Approach (Merge Sort on Linked List)

**Idea:** Recursively split the list into halves using slow-fast to find middle. Sort both halves recursively and merge them with `mergeTwoLL` which stitches nodes by `next` pointers (no new nodes).

**Helper ‚Äî findMiddle:** returns the node at the end of left half (slow pointer technique).

**Helper ‚Äî mergeTwoLL:** merges two sorted lists by adjusting `next` pointers and returns merged head.

**Code:**

```cpp
class Solution {
private: 
    ListNode* findMiddle(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head->next;
        while(fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    ListNode* mergeTwoLL(ListNode* list1, ListNode* list2) {
        ListNode* dummyNode = new ListNode(-1);
        ListNode* temp = dummyNode;

        while(list1 != NULL && list2 != NULL) {
            if(list1->val < list2->val) {
                temp->next = list1;
                temp = list1;
                list1 = list1->next;
            } else {
                temp->next = list2;
                temp = list2;
                list2 = list2->next;
            }
        }

        if(list1) temp->next = list1;
        else temp->next = list2;

        ListNode* head = dummyNode->next;
        delete dummyNode; // avoid memory leak
        return head;
    }

public:
    ListNode* sortList(ListNode* head) {
        if(head == NULL || head->next == NULL) return head;

        ListNode* middle = findMiddle(head);
        ListNode* right = middle->next;
        middle->next = nullptr; // split
        ListNode* left = head;

        left = sortList(left);
        right = sortList(right);

        return mergeTwoLL(left, right);
    }
};
```

**Why merge sort fits linked lists:**  
- Splitting uses pointer ops, not random access ‚Äî `findMiddle` is O(N) per level.  
- Merging can be done in-place by relinking `next` pointers (no extra arrays).  
- Recursion depth is `O(log N)`.

**Complexity:**  
- Time: `O(N log N)` ‚Äî recurrence T(N)=2T(N/2)+O(N)  
- Space: `O(log N)` due to recursion stack (if counted). Algorithm itself uses O(1) extra heap memory beyond that (we deleted the dummy).

**Edge cases & tips:**  
- Make sure to `middle->next = nullptr` to split lists ‚Äî forgetting this causes cycles or incorrect merges.  
- Free the dummy node to be tidy. Alternately, return `dummy->next` and keep dummy on stack (it gets freed automatically at end of function) ‚Äî but deleting explicit is fine.  
- For very large lists, recursion can hit stack limits ‚Äî iterative bottom-up merge sort avoids recursion depth issues.

---

## ‚úÖ Summary Table

| Problem | Best Approach | Time | Extra Space |
|--------:|---------------|------:|-----------:|
| Delete Middle Node | Two-pointer single-pass | O(N) | O(1) |
| Sort Linked List | Merge Sort on linked list | O(N log N) | O(log N) recursion stack |

---

## ‚úÖ Suggested Tests
- Empty list, single node, two nodes.  
- Even and odd length lists for middle deletion.  
- Already sorted, reverse-sorted, duplicates for sortList.  
- Very large list to test recursion limits (consider iterative merge-sort if needed).

---

*Author: Varun Mendre*
