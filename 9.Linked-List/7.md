**Problem 1: Reverse Nodes in k-Group**

### Approach:
The goal is to reverse nodes of a linked list in groups of size **k**. If the number of nodes left is less than **k**, they remain in the same order.

### Steps:
1. **Find the kth node** from the current node.
   - If there are fewer than `k` nodes, no reversal is done.
2. **Reverse the sublist** of `k` nodes using the helper function `reverserLL()`.
3. **Connect the reversed sublist** with the previous part of the list.
4. Continue the process until the end of the list.

### Code:
```cpp
class Solution {
private:
    ListNode* reverserLL(ListNode* head) {
        ListNode* temp = head;
        ListNode* prev = NULL;

        while(temp != NULL) {
            ListNode* front = temp->next;
            temp->next = prev;
            prev = temp;
            temp = front;
        }
        return prev;
    }

    ListNode* findKthNode(ListNode* temp, int k) {
        k -= 1;
        while(temp != NULL && k > 0) {
            k--;
            temp = temp->next;
        }
        return temp;
    }

public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* temp = head;
        ListNode* prevNode = NULL;

        while(temp != NULL) {
            ListNode* kthNode = findKthNode(temp, k);
            if(kthNode == NULL) {
                if(prevNode) prevNode->next = temp;
                break;
            }

            ListNode* nextNode = kthNode->next;
            kthNode->next = NULL;

            reverserLL(temp);

            if(temp == head) {
                head = kthNode;
            } else {
                prevNode->next = kthNode;
            }

            prevNode = temp;
            temp = nextNode;
        }
        return head;
    }
};
```

### Complexity:
- **Time Complexity:** O(2N)
  - O(N) for traversing and O(N) for reversing groups.
- **Space Complexity:** O(1)
  - No extra space used except a few pointers.

---

**Problem 2: Rotate List**

### Approach:
We need to rotate the linked list to the right by **k** places. This means each node moves **k** steps ahead cyclically.

### Steps:
1. **Find the length** of the list.
2. **Adjust `k`** as `k % len` to handle rotations larger than list length.
3. **Make the list circular** by connecting the last node to the head.
4. **Find the new head** by moving `(len - k)` steps from the beginning.
5. **Break the circle** by setting the new tail's `next` to NULL.

### Code:
```cpp
class Solution {
private:
    ListNode* findNthNode(ListNode* head, int k) {
        ListNode* temp = head;
        int cnt = 1;
        while(temp != NULL) {
            if(cnt == k) return temp;
            cnt++;
            temp = temp->next;
        }
        return temp;
    }

public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(head == NULL || head->next == NULL) return head;

        int len = 1;
        ListNode* tail = head;

        while(tail->next != NULL) {
            tail = tail->next;
            len += 1;
        }

        if(k % len == 0) return head;

        k = k % len;
        tail->next = head;

        ListNode* newNode = findNthNode(head, len - k);

        head = newNode->next;
        newNode->next = NULL;

        return head;
    }
};
```

### Complexity:
- **Time Complexity:** O(2N)
  - O(N) to find length and O(N) to rotate.
- **Space Complexity:** O(1)
  - Constant extra space used.

