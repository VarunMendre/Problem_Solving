# Linked List Problems â€” Finding Middle Node & Reversing a Linked List

---

## ğŸ§© Problem 1: Find the Middle of a Linked List

### ğŸ” Problem Statement:
Given the head of a singly linked list, return the middle node.  
If there are two middle nodes, return the **second middle** node.

### ğŸ’¡ Approach: (Tortoise & Hare Algorithm)
We use **two pointers** â€” `slow` and `fast`.
- `slow` moves one step at a time.
- `fast` moves two steps at a time.
When `fast` reaches the end, `slow` will be at the middle.

### âœ… Code:
```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;

        while(fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }

        return slow;
    }
};
```

### â±ï¸ Time Complexity: O(N)  
### ğŸ§® Space Complexity: O(1)

---

## ğŸ§© Problem 2: Reverse a Linked List

### ğŸ” Problem Statement:
Given the head of a singly linked list, reverse the list and return its new head.

---

### ğŸ§± 1. Naive Approach â€” Using a Stack
**Idea:** Store all node values in a stack, then reassign them in reverse order.

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        stack<int>st;
        ListNode* temp = head;

        while(temp != NULL) {
            st.push(temp->val);
            temp = temp->next;
        }
        temp = head;
        while(temp != NULL) {
            temp->val = st.top();
            st.pop();
            temp = temp->next;
        }
        return head;
    }
};
```

â±ï¸ **Time:** O(2N)  
ğŸ§® **Space:** O(N)

---

### âš™ï¸ 2. Optimized Iterative Approach
**Idea:** Reverse the links directly by adjusting pointers.

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* temp = head;
        ListNode* prev = NULL;

        while(temp != NULL) {
            ListNode* front = temp->next;
            temp->next = prev;
            prev = temp;
            temp = front;
        }
        return prev;
    }
};
```

â±ï¸ **Time:** O(N)  
ğŸ§® **Space:** O(1)

---

### ğŸ” 3. Recursive Approach
**Idea:** Use recursion to reach the end of the list, then reverse pointers while backtracking.

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == NULL || head->next == NULL) return head;

        ListNode* newHead = reverseList(head->next);

        ListNode* front = head->next;
        front->next = head;
        head->next = NULL;

        return newHead;
    }
};
```

â±ï¸ **Time:** O(N)  
ğŸ§® **Space:** O(N) (Recursion stack)

---

## ğŸ§© Summary Comparison

| Approach | Technique | Time | Space | Key Concept |
|-----------|------------|------|--------|--------------|
| Stack | Extra Memory | O(2N) | O(N) | Value Swapping |
| Iterative | In-Place | O(N) | O(1) | Pointer Reversal |
| Recursive | Divide & Conquer | O(N) | O(N) | Backtracking |

---

## ğŸ§© Example Dry Run

For list `1 â†’ 2 â†’ 3 â†’ 4 â†’ 5`:

**Iterative Reverse:**
```
Iteration 1: 2 â†’ 3 â†’ 4 â†’ 5 â† 1
Iteration 2: 3 â†’ 4 â†’ 5 â† 2 â† 1
...
Final: 5 â†’ 4 â†’ 3 â†’ 2 â†’ 1
```

---

âœ… **Concepts Covered:**
- Tortoise & Hare algorithm
- Iterative pointer manipulation
- Recursive backtracking in linked lists
