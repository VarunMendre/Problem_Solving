# Linked List Problems — Finding Middle Node & Reversing a Linked List

---

## 🧩 Problem 1: Find the Middle of a Linked List

### 🔍 Problem Statement:
Given the head of a singly linked list, return the middle node.  
If there are two middle nodes, return the **second middle** node.

### 💡 Approach: (Tortoise & Hare Algorithm)
We use **two pointers** — `slow` and `fast`.
- `slow` moves one step at a time.
- `fast` moves two steps at a time.
When `fast` reaches the end, `slow` will be at the middle.

### ✅ Code:
```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;

        while(fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }

        return slow;
    }
};
```

### ⏱️ Time Complexity: O(N)  
### 🧮 Space Complexity: O(1)

---

## 🧩 Problem 2: Reverse a Linked List

### 🔍 Problem Statement:
Given the head of a singly linked list, reverse the list and return its new head.

---

### 🧱 1. Naive Approach — Using a Stack
**Idea:** Store all node values in a stack, then reassign them in reverse order.

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        stack<int>st;
        ListNode* temp = head;

        while(temp != NULL) {
            st.push(temp->val);
            temp = temp->next;
        }
        temp = head;
        while(temp != NULL) {
            temp->val = st.top();
            st.pop();
            temp = temp->next;
        }
        return head;
    }
};
```

⏱️ **Time:** O(2N)  
🧮 **Space:** O(N)

---

### ⚙️ 2. Optimized Iterative Approach
**Idea:** Reverse the links directly by adjusting pointers.

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* temp = head;
        ListNode* prev = NULL;

        while(temp != NULL) {
            ListNode* front = temp->next;
            temp->next = prev;
            prev = temp;
            temp = front;
        }
        return prev;
    }
};
```

⏱️ **Time:** O(N)  
🧮 **Space:** O(1)

---

### 🔁 3. Recursive Approach
**Idea:** Use recursion to reach the end of the list, then reverse pointers while backtracking.

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == NULL || head->next == NULL) return head;

        ListNode* newHead = reverseList(head->next);

        ListNode* front = head->next;
        front->next = head;
        head->next = NULL;

        return newHead;
    }
};
```

⏱️ **Time:** O(N)  
🧮 **Space:** O(N) (Recursion stack)

---

## 🧩 Summary Comparison

| Approach | Technique | Time | Space | Key Concept |
|-----------|------------|------|--------|--------------|
| Stack | Extra Memory | O(2N) | O(N) | Value Swapping |
| Iterative | In-Place | O(N) | O(1) | Pointer Reversal |
| Recursive | Divide & Conquer | O(N) | O(N) | Backtracking |

---

## 🧩 Example Dry Run

For list `1 → 2 → 3 → 4 → 5`:

**Iterative Reverse:**
```
Iteration 1: 2 → 3 → 4 → 5 ← 1
Iteration 2: 3 → 4 → 5 ← 2 ← 1
...
Final: 5 → 4 → 3 → 2 → 1
```

---

✅ **Concepts Covered:**
- Tortoise & Hare algorithm
- Iterative pointer manipulation
- Recursive backtracking in linked lists
