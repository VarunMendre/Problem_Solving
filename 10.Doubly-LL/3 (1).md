# 🧩 Doubly Linked List Problems – Advanced Operations

This document covers **three important problems** on **Doubly Linked Lists (DLL)** – deletion, finding pairs with a given sum, and removing duplicates. Each is explained in detail with step-by-step logic, time and space analysis, and intuitive reasoning.

---

## 🧠 Problem 1: Delete All Occurrences of a Given Key in a DLL

### 🧾 Code:
```cpp
Node * deleteAllOccurrences(Node* head, int k) {
    Node* temp = head;

    while(temp != NULL) {
        if(temp->data == k) {
            if(temp == head) {
                head = temp->next;
            }

            Node* nextNode = temp->next;
            Node* prevNode = temp->prev;

            if(nextNode != NULL) nextNode->prev = prevNode;
            if(prevNode != NULL) prevNode->next = nextNode;

            delete temp;
            temp = nextNode;
        } else {
            temp = temp->next;
        }
    }
    return head;
}
```

### 💡 Explanation:
1. Traverse the DLL node by node.  
2. Whenever a node with value `k` is found, unlink it carefully from both sides:
   - Adjust `prev->next` and `next->prev`.
   - Update `head` if the deleted node was the first node.
3. Free memory using `delete`.
4. Move to the next node.

### 🕒 Time Complexity: `O(N)`  
### 💾 Space Complexity: `O(1)`  

Efficient and in-place deletion.

---

## 🎯 Problem 2: Find Pairs with a Given Sum in DLL

### 🔹 Naive Approach
```cpp
vector<pair<int, int>> findPairs(Node* head, int k) {
    Node* temp1 = head;
    vector<pair<int, int>> ans;

    while(temp1 != NULL) {
        Node* temp2 = temp1->next;
        while(temp2 != NULL && temp1->data + temp2->data <= k) {
            if(temp1->data + temp2->data == k) {
                ans.push_back({temp1->data, temp2->data});
            }
            temp2 = temp2->next;
        }
        temp1 = temp1->next;
    }
    return ans;
}
```

### ⚙️ Optimal Approach (Two-Pointer Technique)
```cpp
Node* findTail(Node* head) {
    Node* tail = head;
    while(tail->next != NULL) {
        tail = tail->next;
    }
    return tail;
}

vector<pair<int, int>> findPairs(Node* head, int k) {
    vector<pair<int, int>> ans;
    if(head == NULL) return ans;

    Node* left = head;
    Node* right = findTail(head);

    while(left->data < right->data) {
        int sum = left->data + right->data;

        if(sum == k) {
            ans.push_back({left->data, right->data});
            left = left->next;
            right = right->prev;
        }
        else if(sum < k) left = left->next;
        else right = right->prev;
    }
    return ans;
}
```

### 💡 Explanation:
1. Use **two pointers**: one at the head (`left`), and one at the tail (`right`).
2. If `sum == k`, record the pair and move both pointers inward.
3. If `sum < k`, move `left` ahead to increase sum.
4. If `sum > k`, move `right` backward to decrease sum.
5. Stop when pointers meet or cross.

### 🕒 Time Complexity: `O(N)`  
### 💾 Space Complexity: `O(1)`  

This is similar to the two-pointer array technique but implemented for DLLs.

---

## 🔁 Problem 3: Remove Duplicates from a Sorted DLL

### 🧾 Code:
```cpp
Node * removeDuplicates(Node *head) {
    Node* temp = head;
    while(temp != NULL && temp->next != NULL) {
        Node* nextNode = temp->next;

        while(nextNode != NULL && nextNode->data == temp->data) {
            Node* duplicate = nextNode;
            nextNode = nextNode->next;
            free(duplicate);
        }

        temp->next = nextNode;
        if(nextNode != NULL) nextNode->prev = temp;

        temp = temp->next;
    }
    return head;
}
```

### 💡 Explanation:
1. Traverse the list and compare each node with its next.  
2. If duplicate values are found, free them and skip ahead.  
3. Adjust both `next` and `prev` pointers to maintain proper linkage.  

### 🕒 Time Complexity: `O(N)`  
### 💾 Space Complexity: `O(1)`  

A simple linear-time cleanup method ensuring no duplicate nodes remain.

---

## 🧩 Summary:
| Problem | Approach | Time | Space | Core Idea |
|----------|-----------|------|--------|------------|
| Delete all occurrences | Iterative | O(N) | O(1) | Pointer manipulation |
| Find pairs with sum | Two-pointer | O(N) | O(1) | Bidirectional traversal |
| Remove duplicates | Linear | O(N) | O(1) | Sorted list cleanup |

---

### ✅ Key Takeaways:
- Understanding DLL traversal from both ends gives flexibility.
- Proper handling of `prev` and `next` ensures no dangling links.
- Mastery of deletion and searching in DLL builds a strong base for complex problems.
