
# Reversing a Doubly Linked List — Deep Dive

**Function**:
```cpp
Node* reverseDLL(Node* head)
{   
      if(head == NULL || head->next == NULL) return head;

      Node* prev = NULL;
      Node* curr = head;

      while(curr != NULL) {
          prev = curr->prev;
          curr->prev = curr->next;
          curr->next = prev;

          curr = curr->prev;
      }

      return prev->prev;
}
```

This document explains the algorithm above in full detail — intuition, working principle, step-by-step dry run, correctness proof, variations, edge cases, common pitfalls, complexity analysis, and alternative implementations (cleaner iterative code + recursive version).

---

## Problem statement (concise)
Given the head of a **doubly linked list (DLL)**, reverse the list **in-place** and return the new head of the reversed list. The DLL nodes have `prev` (or `back`) and `next` pointers. Reversal should swap directions so traversal from the returned head using `next` visits nodes in the original reverse order.

---

## Intuition (what the algorithm does)
For a doubly linked list each node has two pointers: `prev` (points left) and `next` (points right). To reverse the list in-place we can swap `prev` and `next` for every node, because after swapping, what was previously the `next` pointer becomes the `prev` pointer, and vice versa. After doing this for every node, the head of the reversed list will be the original tail.

The algorithm walks through the list once, swapping the two pointers on each node. A careful choice of how to progress to the next node is necessary because after swapping pointers the meaning of `next` and `prev` changes.

---

## How the provided code works (line-by-line)

```cpp
Node* reverseDLL(Node* head)
{   
      if(head == NULL || head->next == NULL) return head;
```
- Handle edge cases: empty list or single-node list — both are already reversed.

```cpp
      Node* prev = NULL;
      Node* curr = head;
```
- `prev` will temporarily hold the original `prev` of `curr` inside the loop (not the final previous node in reversed list).
- `curr` is the iterator starting at original head.

```cpp
      while(curr != NULL) {
          prev = curr->prev;
          curr->prev = curr->next;
          curr->next = prev;

          curr = curr->prev;
      }
```
- `prev = curr->prev;` — save original `prev` pointer of current node.
- `curr->prev = curr->next;` — assign the `next` pointer to `prev` field (swap half).
- `curr->next = prev;` — assign saved original `prev` to `next` field (complete swap).
- `curr = curr->prev;` — advance `curr`. Note: after swapping, `curr->prev` now contains the original `next` pointer — so moving to `curr->prev` advances forward in the original list.

This loop repeats until `curr` becomes `NULL` (we've stepped past the original tail).

```cpp
      return prev->prev;
}
```
- After the loop finishes, `prev` contains the value of `curr->prev` from the last iteration (which is the original `prev` of the last processed node). Due to the swapping, `prev->prev` points to the node that is the new head (original tail). Returning `prev->prev` gives the new head of the reversed list.

> Explanation of the final return: the code is slightly non-intuitive at the end; it relies on the relationships after the last iteration. A clearer result-check is given in the "Clean iterative version" section below.

---

## Visual dry-run (example)

Take list: `A <-> B <-> C`  
Pointers (prev, next) initially:
- `A.prev = NULL`, `A.next = B`
- `B.prev = A`, `B.next = C`
- `C.prev = B`, `C.next = NULL`

Initial: `head = A`, `curr = A`, `prev = NULL`.

**Iteration 1 (curr = A)**:
- `prev = curr->prev`  → `prev = NULL`
- `curr->prev = curr->next` → `A.prev = B`   (A.prev now points to B)
- `curr->next = prev` → `A.next = NULL`    (A.next now NULL)
- `curr = curr->prev` → `curr = B`          (advance to original next)

List now (partial updated):
- `A.prev = B`, `A.next = NULL`  (links reversed at A)

**Iteration 2 (curr = B)**:
- `prev = B->prev` → `prev = A`   (note: B.prev was still A at this moment)
- `B->prev = B->next` → `B.prev = C`
- `B->next = prev` → `B.next = A`
- `curr = B->prev` → `curr = C`

Now:
- `B.prev = C`, `B.next = A`

**Iteration 3 (curr = C)**:
- `prev = C->prev` → `prev = B`
- `C->prev = C->next` → `C.prev = NULL`
- `C->next = prev` → `C.next = B`
- `curr = C->prev` → `curr = NULL` (loop ends)

After loop:
- `A: prev=B next=NULL`
- `B: prev=C next=A`
- `C: prev=NULL next=B`

This is the reversed list `C <-> B <-> A`. Now what is `prev`?
- In last iteration we set `prev = B`. Therefore `prev->prev = B->prev = C`, which is head of reversed list. So return `prev->prev` → `C`. Works.

---

## Correctness proof (informal)
- For each node `x`, the code swaps `x->prev` and `x->next`. After processing every node this way, the original `next` direction is reversed to become the `prev` direction and vice versa.
- The traversal moves along original `next` pointers because after swapping, `curr = curr->prev` follows the original `next` node.
- Once all nodes have been processed, the node whose `prev` becomes `NULL` is the original tail — it's the head of the reversed list. The final return expression in the provided code (`prev->prev`) correctly yields this node (based on the state of `prev` at loop exit), as seen in the dry run.

---

## Clean iterative alternative (more readable)
The original code is efficient but the final `return prev->prev` is the trickiest part to understand. Here's a clearer variant that achieves the same goal and returns the new head directly:

```cpp
Node* reverseDLL(Node* head) {
    if (!head || !head->next) return head;

    Node* curr = head;
    Node* newHead = nullptr;

    while (curr) {
        // swap prev and next
        Node* tmp = curr->prev;
        curr->prev = curr->next;
        curr->next = tmp;

        // after swap, tmp holds original prev.
        // if curr->prev is NULL, curr is the new head (original tail)
        if (curr->prev == NULL) newHead = curr;

        // move to the next original node (which is curr->prev after swap)
        curr = curr->prev;
    }
    return newHead;
}
```

**Why this is clearer**:
- We track `newHead` explicitly when we find the node whose `prev` becomes `NULL` (the original tail).
- No cryptic `prev->prev` return; the code is self-documenting.

---

## Recursive approach (for completeness)
A recursive solution is possible but not as straightforward for DLLs because we need to swap pointers and return new head. Here's a simple recursive template idea (not recommended for very long lists due to recursion depth):

```cpp
Node* reverseDLLRecursive(Node* head) {
    if (!head) return head;
    // swap prev and next
    Node* temp = head->prev;
    head->prev = head->next;
    head->next = temp;

    // if prev is NULL after swap, this is new head
    if (!head->prev) return head;

    // otherwise, keep recursing on the next node in original direction:
    return reverseDLLRecursive(head->prev);
}
```

This recursive function swaps pointers at `head`, and continues on the original next node (which becomes `head->prev` after swap). When a node's `prev` becomes NULL, that node is the new head.

---

## Edge cases & pitfalls
- **Empty list (`head == NULL`)**: return `NULL`.
- **Single node**: return the node itself.
- **Memory ownership**: the algorithm operates *in-place* and does not allocate or free nodes (except any external deletions). Ensure you do not `free` nodes here.
- **Pointer field names**: some code uses `prev` and `next`, others `back` and `next`. Use the correct names consistently.
- **Final return value**: returning the wrong node is the most common bug. Use the clearer `newHead` approach to avoid mistakes.
- **Null dereference**: ensure checks before accessing `prev->prev` if you use the original pattern. The original code assumes at least two nodes — but has an early return to handle that case.

---

## Complexity analysis
- **Time Complexity:** `O(N)` — we visit each node exactly once.
- **Space Complexity:** `O(1)` — in-place; only a few pointer variables used.

---

## Tests you should run
- Empty list (`NULL`)
- Single-node list
- Two-node list
- Three-node list
- Longer list (e.g., even and odd lengths)
- Lists where nodes contain repeated values (values don't matter; pointers do)
- Verify you can traverse the returned head using `next` and get the expected sequence.

---

## Full example with main() (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
    Node(int val): data(val), prev(nullptr), next(nullptr) {}
};

Node* construct(vector<int> a) {
    if (a.empty()) return nullptr;
    Node* head = new Node(a[0]);
    Node* cur = head;
    for (size_t i = 1; i < a.size(); ++i) {
        Node* n = new Node(a[i]);
        cur->next = n;
        n->prev = cur;
        cur = n;
    }
    return head;
}

void printForward(Node* head) {
    while (head) {
        cout << head->data;
        if (head->next) cout << " <-> ";
        head = head->next;
    }
    cout << "\n";
}

void printBackward(Node* tail) {
    while (tail) {
        cout << tail->data;
        if (tail->prev) cout << " <-> ";
        tail = tail->prev;
    }
    cout << "\n";
}

// Clean iterative version from above
Node* reverseDLL(Node* head) {
    if (!head || !head->next) return head;

    Node* curr = head;
    Node* newHead = nullptr;

    while (curr) {
        Node* tmp = curr->prev;
        curr->prev = curr->next;
        curr->next = tmp;

        if (curr->prev == NULL) newHead = curr;
        curr = curr->prev; // move to original next
    }
    return newHead;
}

int main() {
    vector<int> arr = {10, 20, 30, 40};
    Node* head = construct(arr);

    cout << "Original list (forward): ";
    printForward(head);

    Node* newHead = reverseDLL(head);

    cout << "Reversed list (forward): ";
    printForward(newHead);

    // also show backward traversal from tail (original head)
    cout << "Reversed list (backward from tail): ";
    // find tail
    Node* tail = newHead;
    while (tail && tail->next) tail = tail->next;
    printBackward(tail);

    return 0;
}
```

---

## Quick checklist for interview-ready answer
- Mention in-place reversal and O(N) time, O(1) extra space.
- Explain pointer swapping `prev <-> next`.
- Explain how to advance the iterator safely (use `curr = curr->prev` after swap to go to original next).
- Handle edge cases (empty or single-node lists).
- Offer a clean implementation that returns the new head unambiguously.

---

## Closing notes
The provided snippet is compact and works correctly for lists with at least two nodes (and it handles smaller sizes via the early return). The clearer implementation that tracks `newHead` or checks `curr->prev == NULL` is easier to reason about and less error-prone. When writing production or interview code, prefer clarity — readability helps avoid subtle pointer mistakes.
